<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://www.alexeyfv.xyz//feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.alexeyfv.xyz//" rel="alternate" type="text/html" /><updated>2024-12-09T04:49:02+00:00</updated><id>http://www.alexeyfv.xyz//feed.xml</id><title type="html">alexeyfv</title><subtitle>Articles about .NET, C# and much more</subtitle><author><name>© 2024 Alexey Fedorov</name><email>your-email@domain.com</email></author><entry><title type="html">Object Pools in C#: Examples, Internals and Performance Benchmarks</title><link href="http://www.alexeyfv.xyz//2024/12/09/object-pool.html" rel="alternate" type="text/html" title="Object Pools in C#: Examples, Internals and Performance Benchmarks" /><published>2024-12-09T00:00:00+00:00</published><updated>2024-12-09T00:00:00+00:00</updated><id>http://www.alexeyfv.xyz//2024/12/09/object-pool</id><content type="html" xml:base="http://www.alexeyfv.xyz//2024/12/09/object-pool.html">&lt;p&gt;Object Pool is a design pattern that allows reusing objects instead of creating new ones. This can be very useful in scenarios where object initialization is expensive. It is widely used, especially in game development and applications where low memory usage is critically important. In this article, we will look at how this pattern is implemented in C# and how it can improve performance.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/12/2024-12-09-object-pool/cover.jpg&quot; alt=&quot;Object Pools in C#: Examples, Internals and Performance Benchmarks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This article is presented as a part of &lt;a href=&quot;https://www.csadvent.christmas/&quot;&gt;C# Advent 2024&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;table-of-contents&quot;&gt;Table Of Contents&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;Table Of Contents&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#disclaimer&quot;&gt;Disclaimer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#what-is-object-pool&quot;&gt;What is Object Pool?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#objectpool-class&quot;&gt;ObjectPool class&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#how-it-works&quot;&gt;How it works&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#performance&quot;&gt;Performance&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#arraypool&quot;&gt;ArrayPool&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#how-it-works-1&quot;&gt;How it works&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#sharedarraypool&quot;&gt;SharedArrayPool&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#configurablearraypool&quot;&gt;ConfigurableArrayPool&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#performance-1&quot;&gt;Performance&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h1&gt;

&lt;p&gt;The results of the benchmarks in this article are very conditional. I admit, that the benchmark may show different results on a different computer, with a different CPU, with a different compiler or in a different scenario. Always check your code in your specific conditions and don’t trust to the articles from the internet.&lt;/p&gt;

&lt;p&gt;The source code and raw results are located in &lt;a href=&quot;https://github.com/alexeyfv/object-pool&quot;&gt;this repo&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;what-is-object-pool&quot;&gt;What is Object Pool?&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Object_pool_pattern&quot;&gt;Object Pool&lt;/a&gt; is a design pattern that allows reusing objects instead of creating new ones. This can be very useful in scenarios where object initialization is expensive. The typical usage of an object pool consists of these steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Rent an object from the pool.&lt;/li&gt;
  &lt;li&gt;Use the object to perform some work.&lt;/li&gt;
  &lt;li&gt;Return the object to the pool.&lt;/li&gt;
  &lt;li&gt;Optionally, the object pool can reset the object’s state when it is returned.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The pseudocode for using an object pool looks like this:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objectPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;c1&quot;&gt;// do some work with obj  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;objectPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The Object Pool pattern is widely used, especially in game development and applications where low memory usage is critically important.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/12/2024-12-09-object-pool/image01.png&quot; alt=&quot;Example of searching Object Pool in GitHub&quot; /&gt;
&lt;strong&gt;
Example of searching Object Pool in GitHub
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;.NET provides several classes that implement the Object Pool pattern:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/aspnet/core/performance/objectpool&quot;&gt;ObjectPool&lt;/a&gt;: A general-purpose object pool.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1&quot;&gt;ArrayPool&lt;/a&gt;: A class designed specifically for pooling arrays.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These classes may look similar, but their implementation is different. We will consider them separately.&lt;/p&gt;

&lt;h1 id=&quot;objectpool-class&quot;&gt;ObjectPool class&lt;/h1&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectPool&lt;/code&gt; class is available by default only in ASP.NET Core applications. You can find Its &lt;a href=&quot;https://github.com/dotnet/aspnetcore/tree/eb68e016a554b4da50d7fb0aeffe897cfabf36c7/src/ObjectPool/src&quot;&gt;source code&lt;/a&gt; here. For other types of C# applications, you need to install the &lt;a href=&quot;https://www.nuget.org/packages/Microsoft.Extensions.ObjectPool/&quot;&gt;Microsoft.Extensions.ObjectPool package&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To use a pool, call the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create&amp;lt;T&amp;gt;&lt;/code&gt; method from the static ObjectPool class:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ObjectPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SomeType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;  
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can also define a custom pooling policy and pass it to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create&amp;lt;T&amp;gt;&lt;/code&gt; method. A policy lets you control how objects are created and cleaned up. For example, to reuse a list of integers, you can define the following policy:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ListPolicy&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IPooledObjectPolicy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now let’s take a look at how the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectPool&lt;/code&gt; class works internally.&lt;/p&gt;

&lt;h2 id=&quot;how-it-works&quot;&gt;How it works&lt;/h2&gt;

&lt;p&gt;When &lt;a href=&quot;https://github.com/dotnet/aspnetcore/blob/eb68e016a554b4da50d7fb0aeffe897cfabf36c7/src/ObjectPool/src/DefaultObjectPool.cs#L48&quot;&gt;retrieving an object from the pool&lt;/a&gt;, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectPool&lt;/code&gt; works as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It checks if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_fastItem&lt;/code&gt; is not null and can be taken by the current thread using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interlocked.CompareExchange&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_fastItem&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt; or already taken by another thread, it tries to dequeue an object from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentQueue _items&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;If both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_fastItem&lt;/code&gt; and the queue are empty, a new object is created using the factory function.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/12/2024-12-09-object-pool/image02.png&quot; alt=&quot;ObjectPool\&amp;lt;T\&amp;gt; internals&quot; /&gt;
&lt;strong&gt;
ObjectPool&amp;lt;T&amp;gt; internals
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When &lt;a href=&quot;https://github.com/dotnet/aspnetcore/blob/eb68e016a554b4da50d7fb0aeffe897cfabf36c7/src/ObjectPool/src/DefaultObjectPool.cs#L76&quot;&gt;returning an object to the pool&lt;/a&gt;, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectPool&lt;/code&gt; works in an opposite way:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It checks if the object passes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_returnFunc&lt;/code&gt; validation. If not, it means that the object should be discarded by &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.objectpool.ipooledobjectpolicy-1?view=net-9.0-pp&quot;&gt;policy&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_fastItem&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;, the object is stored there using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interlocked.CompareExchange&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_fastItem&lt;/code&gt; is already in use, the object is added to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentQueue&lt;/code&gt; if the total number of items is within the maximum capacity.&lt;/li&gt;
  &lt;li&gt;If the pool is full, the object is discarded, and the item count is adjusted.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;To test how &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectPool&amp;lt;T&amp;gt;&lt;/code&gt; affects performance, I created &lt;a href=&quot;https://github.com/alexeyfv/object-pool/blob/main/ObjectPoolBenchmark.cs&quot;&gt;two benchmarks&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;without pooling (creates a new list for each operation);&lt;/li&gt;
  &lt;li&gt;with the object pool.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each benchmark does the following in a loop:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Creates a new list or rents from the pool.&lt;/li&gt;
  &lt;li&gt;Adds the values in the list.&lt;/li&gt;
  &lt;li&gt;Returns the list to the pool (if pooling is used).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The benchmarks repeat this process 100 times for each thread. The threads count varies from 1 to 32. The list size varies from 10 to 1,000,000.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/alexeyfv/object-pool/tree/main/BenchmarkDotNet.Artifacts/results&quot;&gt;results&lt;/a&gt; are shown in the diagram below. The x-axis is a logarithmic scale, and the y-axis shows the percentage difference compared to the baseline without pooling.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/12/2024-12-09-object-pool/image03.png&quot; alt=&quot;ObjectPool&amp;lt;T&amp;gt; benchmark results. Percentage difference compared to the baseline without pooling.&quot; /&gt;
&lt;strong&gt;
ObjectPool&amp;lt;T&amp;gt; benchmark results. Percentage difference compared to the baseline without pooling.
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;From the results, we can see that using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectPool&lt;/code&gt; in a single-thread scenario is 10% – 50% faster, compared to creating a new list for each iteration. However, in a multithreaded scenario, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectPool&lt;/code&gt; performs worse for relatively small objects. This is most probably due to thread synchronization latency when accessing to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_fastItem&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentQueue&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/12/2024-12-09-object-pool/image04.png&quot; alt=&quot;ObjectPool&amp;lt;T&amp;gt; benchmark results. Absolute values.&quot; /&gt;
&lt;strong&gt;
ObjectPool&amp;lt;T&amp;gt; benchmark results. Absolute values.
&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;arraypool&quot;&gt;ArrayPool&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt; is a class which is available from any C# application. It locates in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.Buffers&lt;/code&gt; namespace. You can find its source code &lt;a href=&quot;https://github.com/dotnet/runtime/tree/234e2f7ec5dd315014f31574719900c0715f9477/src/libraries/System.Private.CoreLib/src/System/Buffers&quot;&gt;here&lt;/a&gt;. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayPool&lt;/code&gt; class is an abstract and has 2 implemenations: &lt;a href=&quot;https://github.com/dotnet/runtime/blob/234e2f7ec5dd315014f31574719900c0715f9477/src/libraries/System.Private.CoreLib/src/System/Buffers/SharedArrayPool.cs&quot;&gt;SharedArrayPool&lt;/a&gt; and &lt;a href=&quot;https://github.com/dotnet/runtime/blob/234e2f7ec5dd315014f31574719900c0715f9477/src/libraries/System.Private.CoreLib/src/System/Buffers/ConfigurableArrayPool.cs&quot;&gt;ConfigurableArrayPool&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The usage of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt; follows the typical object pool pattern and is quite simple. Here’s an example that uses the shared pool internally.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Rent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;c1&quot;&gt;// do some work with array  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can also configure the pool. Static method Create returns a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConfigurableArrayPool&lt;/code&gt; instance.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maxArrayLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;maxArraysPerBucket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This method lets you specify the maximum array length and the maximum number of arrays per bucket (we’ll learn about buckets later). By default, these values are &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2^20&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;It’s important to note that the size of the array returned will always meet the requested size, but it may be larger:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Rent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;  
        &lt;span class=&quot;s&quot;&gt;&quot;Renting #{0}. Requested size: {1}. Actual size: {2}.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   
        &lt;span class=&quot;p&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Renting #1. Requested size: 15. Actual size: 16.  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Renting #2. Requested size: 31. Actual size: 32.  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Renting #3. Requested size: 63. Actual size: 64.  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Renting #26. Requested size: 536870911. Actual size: 536870912.  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Renting #27. Requested size: 1073741823. Actual size: 1073741824.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;how-it-works-1&quot;&gt;How it works&lt;/h2&gt;

&lt;p&gt;As said earlier, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt; has 2 implementations. We will consider them separately.&lt;/p&gt;

&lt;h3 id=&quot;sharedarraypool&quot;&gt;SharedArrayPool&lt;/h3&gt;

&lt;p&gt;SharedArrayPool has 2 tiers of cache: per-thread and shared caches.&lt;/p&gt;

&lt;p&gt;The per-thread cache is implemented as a private static field named &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_tlsBuckets&lt;/code&gt;, which is essentially an array of arrays. Each thread gets its own instance of this cache due to &lt;a href=&quot;https://en.wikipedia.org/wiki/Thread-local_storage&quot;&gt;Thread Local Storage&lt;/a&gt;, achieved by applying the &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.threadstaticattribute?view=net-8.0&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadStaticAttribute&lt;/code&gt;&lt;/a&gt; to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_tlsBuckets&lt;/code&gt; field.&lt;br /&gt;
This allows each thread to maintain a small cache for various array sizes, ranging from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2^4&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2^30&lt;/code&gt; (27 buckets in total).&lt;/p&gt;

&lt;p&gt;When we’re trying to get an array from a pool, the algorithm tries to get it from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_tlsBuckets&lt;/code&gt; field. If an array of the needed size is not found in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_tlsBuckets&lt;/code&gt;, the algorithm checks the shared cache, stored in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_buckets&lt;/code&gt;. This shared cache is an array of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Partitions&lt;/code&gt; objects, one for each allowed bucket size (27 buckets in total). Each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Partitions&lt;/code&gt; object contains an array of N &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Partition&lt;/code&gt; objects, where N is the number of processors. Each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Partition&lt;/code&gt; works like a stack that can hold up to 32 arrays. Yeah, sounds complicated, so see the diagram below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/12/2024-12-09-object-pool/image05.png&quot; alt=&quot;SharedArrayPool&amp;lt;T&amp;gt; internals&quot; /&gt;
&lt;strong&gt;
SharedArrayPool&amp;lt;T&amp;gt; internals
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When we’re returning the array to the pool, the algorithm first tries to store it in the per-thread cache. If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_tlsBuckets&lt;/code&gt; already contains an array for the same size, the existing array from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_tlsBuckets&lt;/code&gt; is pushed into the shared cache and the new array is saved in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t_tlsBuckets&lt;/code&gt; for better performance (CPU cache locality). If the current core’s stack is full, it searches for space in the stacks of other cores. If all stacks are full, the array is dropped.&lt;/p&gt;

&lt;h3 id=&quot;configurablearraypool&quot;&gt;ConfigurableArrayPool&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConfigurableArrayPool&lt;/code&gt; is simpler compared to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedArrayPool&lt;/code&gt;. It has only one private field for storing pooled arrays, called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_buckets&lt;/code&gt;. This field is an array of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bucket&lt;/code&gt; instances, where each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bucket&lt;/code&gt; represents a collection of arrays (see the diagram below). Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_buckets&lt;/code&gt; field is shared across all threads, each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bucket&lt;/code&gt; &lt;a href=&quot;https://github.com/dotnet/runtime/blob/234e2f7ec5dd315014f31574719900c0715f9477/src/libraries/System.Private.CoreLib/src/System/Buffers/ConfigurableArrayPool.cs#L191&quot;&gt;uses a SpinLock&lt;/a&gt; for thread-safe access.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/12/2024-12-09-object-pool/image06.png&quot; alt=&quot;ConfigurableArrayPool&amp;lt;T&amp;gt; internals&quot; /&gt;
&lt;strong&gt;
ConfigurableArrayPool&amp;lt;T&amp;gt; internals
&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;performance-1&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt; &lt;a href=&quot;https://github.com/alexeyfv/object-pool/blob/main/ArrayPoolBenchmark.cs&quot;&gt;benchmarks&lt;/a&gt; are similar to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectPool&amp;lt;T&amp;gt;&lt;/code&gt; benchmarks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;without pooling (creates a new array for each operation);&lt;/li&gt;
  &lt;li&gt;with the shared pool;&lt;/li&gt;
  &lt;li&gt;with the configurable pool.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/12/2024-12-09-object-pool/image07.png&quot; alt=&quot;ArrayPool&amp;lt;T&amp;gt; benchmark results. Percentage difference compared to the baseline without pooling.&quot; /&gt;
&lt;strong&gt;
ArrayPool&amp;lt;T&amp;gt; benchmark results. Percentage difference compared to the baseline without pooling.
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As we can see from the results, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedArrayPool&lt;/code&gt; is faster almost in all cases, especially with a multiple threads scenario. The only exception is when the array size is 10.&lt;/p&gt;

&lt;p&gt;The opposite situation with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConfiguratbleArrayPool&lt;/code&gt;. This class has worse performance in multithreading scenario for relatively small arrays. I believe the reason is the same as in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectPool&amp;lt;T&amp;gt;&lt;/code&gt;: thread synchronization latency when accessing arrays inside Bucket instances.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/12/2024-12-09-object-pool/image08.png&quot; alt=&quot;ArrayPool&amp;lt;T&amp;gt; benchmark results. Absolute values.&quot; /&gt;
&lt;strong&gt;
ArrayPool&amp;lt;T&amp;gt; benchmark results. Absolute values.
&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectPool&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayPool&lt;/code&gt; can improve performance in scenarios where objects are expensive to create and reuse is possible. However, in multithreaded scenarios, the benefits of pooling are less clear. For small objects, the overhead of synchronization mechanisms can outweigh the performance gains. Developers should carefully benchmark and evaluate pooling in their specific use cases before integrating it into production systems.&lt;/p&gt;</content><author><name>© 2024 Alexey Fedorov</name><email>your-email@domain.com</email></author><category term="csharp" /><category term="objectpool" /><category term="performance" /><category term="benchmark" /><category term="algorithms" /><summary type="html">Object Pool is a design pattern that allows reusing objects instead of creating new ones. This can be very useful in scenarios where object initialization is expensive. It is widely used, especially in game development and applications where low memory usage is critically important. In this article, we will look at how this pattern is implemented in C# and how it can improve performance. This article is presented as a part of C# Advent 2024.</summary></entry><entry><title type="html">FrozenDictionary under the hood: how fast is it comparing to Dictionary and why</title><link href="http://www.alexeyfv.xyz//2024/10/09/frozen-dictionary.html" rel="alternate" type="text/html" title="FrozenDictionary under the hood: how fast is it comparing to Dictionary and why" /><published>2024-10-09T00:00:00+00:00</published><updated>2024-10-09T00:00:00+00:00</updated><id>http://www.alexeyfv.xyz//2024/10/09/frozen-dictionary</id><content type="html" xml:base="http://www.alexeyfv.xyz//2024/10/09/frozen-dictionary.html">&lt;p&gt;With &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8/runtime#performance-focused-types&quot;&gt;.NET 8 release&lt;/a&gt;, C# developers received a new type of generic collections – &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt;. The main feature of this dictionary is that it’s immutable, but allows reading the data faster comparing to a plain &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;. I split the results on the cover by a reason: the algorithms used in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; are highly depended on key type, the size of the array or even the number of the string keys with the same length. In this article, we’ll look into details how fast is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; and why.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image01.png&quot; alt=&quot;FrozenDictionary performance comparing to Dictionary&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Version in Russian is &lt;a href=&quot;/2024/08/22/frozen-dictionary.html&quot;&gt;here&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Версия на русском &lt;a href=&quot;/2024/08/22/frozen-dictionary.html&quot;&gt;тут&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;Table of Contents&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#before-we-get-started&quot;&gt;Before we get started&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#disclaimer&quot;&gt;Disclaimer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#group-1-default-dictionaries&quot;&gt;Group 1. Default dictionaries&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#search-algorithm&quot;&gt;Search algorithm&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#benchmark&quot;&gt;Benchmark&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#group-2-dictionary-for-int32-keys&quot;&gt;Group 2. Dictionary for Int32 keys&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#search-algorithm-1&quot;&gt;Search algorithm&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#benchmark-1&quot;&gt;Benchmark&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#group-3-dictionary-with-bucket-sort-algorithm&quot;&gt;Group 3. Dictionary with bucket sort algorithm&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#search-algorithm-2&quot;&gt;Search algorithm&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#benchmark-2&quot;&gt;Benchmark&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#group-4-dictionary-with-string-keys&quot;&gt;Group 4. Dictionary with string keys&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#search-algorithm-3&quot;&gt;Search algorithm&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#benchmark-3&quot;&gt;Benchmark&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#group-5-small-dictionaries&quot;&gt;Group 5. Small dictionaries&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#search-algorithm-4&quot;&gt;Search algorithm&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#benchmark-4&quot;&gt;Benchmark&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;before-we-get-started&quot;&gt;Before we get started&lt;/h2&gt;

&lt;p&gt;It’s important to notice, that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; is an abstract class with &lt;a href=&quot;https://github.com/dotnet/runtime/tree/51e99e12a8a09c69e30fdcb004facf68f73173a6/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen&quot;&gt;multiple derived classes&lt;/a&gt;. To be precise, there are 18 classes. Instead of explaining which implementation is used when, just look at the diagram in Figure 1.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image02.png&quot; alt=&quot;Choosing a FrozenDictionary implementation&quot; /&gt;
&lt;strong&gt;
Figure 1 – Choosing a FrozenDictionary implementation
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Don’t be afraid, because all these 18 implementations can be combined into 5 groups:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;In &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/DefaultFrozenDictionary.cs&quot;&gt;DefaultFrozenDictionary&lt;/a&gt; and &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/ValueTypeDefaultComparerFrozenDictionary.cs&quot;&gt;ValueTypeDefaultComparerFrozenDictionary&lt;/a&gt; a &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs&quot;&gt;FrozenHashTable&lt;/a&gt; is used.&lt;/li&gt;
  &lt;li&gt;In Int32FrozenDictionary the FrozenHashTable is also used, but there is no hash code calculation, because the key is hash code itself.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/LengthBucketsFrozenDictionary.cs&quot;&gt;LengthBucketsFrozenDictionary&lt;/a&gt; uses an algorithm which is similar to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bucket_sort&quot;&gt;bucket sort&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;All 11 &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs&quot;&gt;OrdinalStringFrozenDictionary&lt;/a&gt; implementations are also use FrozenHashTable, but they have a specific hash code calculation algorithm.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallValueTypeComparableFrozenDictionary.cs#L18&quot;&gt;SmallValueTypeComparableFrozenDictionary&lt;/a&gt;, &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallValueTypeDefaultComparerFrozenDictionary.cs#L12&quot;&gt;SmallValueTypeDefaultComparerFrozenDictionary&lt;/a&gt; and &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallFrozenDictionary.cs#L18&quot;&gt;SmallFrozenDictionary&lt;/a&gt; use linear search, because their size is not greater than 10 elements.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The choosing of the appropriate implementation depends on the multiple parameters and done in &lt;a href=&quot;https://github.com/dotnet/runtime/blob/51e99e12a8a09c69e30fdcb004facf68f73173a6/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenDictionary.cs#L113&quot;&gt;CreateFromDictionary method of a FrozenDictionary static class&lt;/a&gt;. Now, let’s take a look at each group separately and their algorithms, and run benchmarks.&lt;/p&gt;

&lt;h2 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h2&gt;

&lt;p&gt;The results of the benchmarks are very conditional. I admit, that the benchmark may show different results on a different computer, with a different CPU, with a different compiler or in a different scenario. Always check your code in your specific conditions and don’t trust to the articles from the internet.&lt;/p&gt;

&lt;p&gt;The source code and raw results are located in &lt;a href=&quot;https://github.com/alexeyfv/frozen-dictionary&quot;&gt;this repo&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;group-1-default-dictionaries&quot;&gt;Group 1. Default dictionaries&lt;/h2&gt;

&lt;p&gt;As I said earlier, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozehHashTable&lt;/code&gt; structure is used in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefaultFrozenDictionary&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ValueTypeDefaultComparerFrozenDictionary&lt;/code&gt;. This structure, as you may guess from its name, is a hash table implementation. For better understanding how &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenHashTable&lt;/code&gt; differs from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;, need to remember how search is implemented in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;. If you already know this part, you may skip the following explanation.&lt;/p&gt;

&lt;p&gt;Let’s consider the following dictionary:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;APPLE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;grape&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;GRAPE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lemon&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;LEMON&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fig&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;FIG&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;LIME&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;kiwi&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;KIWI&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;record&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When, for example, we search a value for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fruit(&quot;fig&quot;)&lt;/code&gt; key, the following are happened in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt; (Figure 2):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Calculate the key &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashcode&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Calculate the index of the bucket (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bucketIndex&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;If the key in the entry is equal to the searchable key, then we return the related value. Otherwise, we go to the next entry and repeat step 3.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image03.png&quot; alt=&quot;Search in Dictionary&quot; /&gt;
&lt;strong&gt;
Figure 2 – Search in Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;search-algorithm&quot;&gt;Search algorithm&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; immutability allows working with buckets differently. Since the number of key-value pairs don’t change, it’s possible to:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/runtime/blob/c788546f9ad43ea17981d5dc9343b00b6f76d98f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs#L47&quot;&gt;Select the number of buckets&lt;/a&gt; so that the number of collisions will be &lt;a href=&quot;https://github.com/dotnet/runtime/blob/3eba70227be23baee21c13a7ab9316d58d469b82/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs#L151&quot;&gt;no more than 5%&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Place keys and values in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_keys&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_values&lt;/code&gt; ​​arrays, instead of a linked list in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;. This makes search more efficient due to higher data locality.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt;, searching for a value for the key &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fruit(&quot;fig&quot;)&lt;/code&gt; would look like this (Figure 3):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Calculate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; of the key.&lt;/li&gt;
  &lt;li&gt;Calculate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bucketIndex&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;In a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bucket&lt;/code&gt; array, receive values &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt;. These values are boundaries in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashCodes&lt;/code&gt; array.&lt;/li&gt;
  &lt;li&gt;Iterate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashCodes&lt;/code&gt; array from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt; and search the key. If found, return the value. Otherwise, return null.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image04.png&quot; alt=&quot;Search in DefaultFrozenDictionary&quot; /&gt;
&lt;strong&gt;
Figure 3 – Search in DefaultFrozenDictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;benchmark&quot;&gt;Benchmark&lt;/h3&gt;

&lt;p&gt;The benchmarks results for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefaultFrozenDictionary&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ValueTypeDefaultComparerFrozenDictionary&lt;/code&gt; are on Figure 4 and 5.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image05.png&quot; alt=&quot;Reading speed from ValueTypeDefaultComparerFrozenDictionary comparing to Dictionary&quot; /&gt;
&lt;strong&gt;
Reading speed from ValueTypeDefaultComparerFrozenDictionary comparing to Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image06.png&quot; alt=&quot;Reading speed from DefaultFrozenDictionary comparing to Dictionary&quot; /&gt;
&lt;strong&gt;
Reading speed from DefaultFrozenDictionary comparing to Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The high search speed in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt; compared to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ValueTypeDefaultComparerFrozenDictionary&lt;/code&gt; for dictionaries with up to 1000 elements is probably due to aggressive &lt;a href=&quot;https://en.wikipedia.org/wiki/Inline_function&quot;&gt;method inlining&lt;/a&gt; in Dictionary. I couldn’t understand why the limit is exactly 1000 elements, as there’s nothing about this in the &lt;a href=&quot;https://github.com/dotnet/runtime/blob/10107d3ca202bf1fda76a1bf575d782be4be27c3/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs&quot;&gt;source code&lt;/a&gt;. It might be related to the JIT compiler’s implementation. If you have any ideas on this, feel free to share them in the comments.&lt;/p&gt;

&lt;p&gt;In other cases, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; is 31-32% faster for value types and 17-18% faster for reference types.&lt;/p&gt;

&lt;h2 id=&quot;group-2-dictionary-for-int32-keys&quot;&gt;Group 2. Dictionary for Int32 keys&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int32FrozenDictionary&lt;/code&gt; also uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenHashTable&lt;/code&gt;. The main feature of this class is that if the key type is an integer, its hash is equal to its value, so collisions in such a dictionary are impossible. For example, you can’t add two elements with the key 123 – an exception will be thrown.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// System.ArgumentException: An item with the same key has already been added.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;search-algorithm-1&quot;&gt;Search algorithm&lt;/h3&gt;

&lt;p&gt;This allows skipping the hash calculation during reads and &lt;a href=&quot;https://github.com/dotnet/runtime/blob/eb455ec34c6709e487c19e52c29ec712a6fa4d7f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/Int32/Int32FrozenDictionary.cs#L35&quot;&gt;using the key’s value directly&lt;/a&gt;. As a result, value lookup works like this (Figure 6):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The bucket index is calculated directly from the key’s value.&lt;/li&gt;
  &lt;li&gt;From the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bucket&lt;/code&gt; array, we get the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt; values, which define the boundaries in the HashCodes array.&lt;/li&gt;
  &lt;li&gt;We iterate through the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashCodes&lt;/code&gt; array from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt;, looking for the target key and return the value when found.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image07.png&quot; alt=&quot;Search in Int32FrozenDictionary&quot; /&gt;
&lt;strong&gt;
Figure 6 – Search in Int32FrozenDictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;benchmark-1&quot;&gt;Benchmark&lt;/h3&gt;

&lt;p&gt;Because of optimizations, reading from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int32FrozenDictionary&lt;/code&gt; is 34-42% faster (Figure 7).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image08.png&quot; alt=&quot;Reading speed from Int32FrozenDictionary comparing to Dictionary&quot; /&gt;
&lt;strong&gt;
Figure 7 – Reading speed from Int32FrozenDictionary comparing to Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;group-3-dictionary-with-bucket-sort-algorithm&quot;&gt;Group 3. Dictionary with bucket sort algorithm&lt;/h2&gt;

&lt;p&gt;When creating “frozen” dictionaries with string keys, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; tries to create the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LengthBucketsFrozenDictionary&lt;/code&gt; class. This class is optimized for situations where keys have different lengths. It achieves this by &lt;a href=&quot;https://github.com/dotnet/runtime/blob/25f82f314b07cc96dd3212ca4ef950b4220516d1/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/LengthBuckets.cs#L17&quot;&gt;distributing the keys into buckets&lt;/a&gt;: for each unique key length, a bucket with a capacity of MaxPerLength = 5 elements is created. Essentially, this is an implementation of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bucket_sort&quot;&gt;block sorting&lt;/a&gt;. To make it clearer, let’s look at an example:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;APPLE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;grape&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;GRAPE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lemon&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;LEMON&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fig&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;FIG&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;LIME&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;kiwi&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;KIWI&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frozenDictionary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ToFrozenDictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There are keys with length of 3, 4 and 5 in the dictionary. Therefore, they can be distributed between 3 buckets (Figure 8):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Bucket for keys of length 3: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fig&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Bucket for keys of length 4: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lime&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kiwi&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Bucket for keys of length 5: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apple&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grape&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lemon&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image09.png&quot; alt=&quot;Distribution of the strings based on their length&quot; /&gt;
&lt;strong&gt;
Figure 8 – Distribution of the strings based on their length
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since we know the minimum (3) and maximum (5) lengths of the keys, there’s no need to create three separate buckets. We can store everything in a single array called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lengthBuckets&lt;/code&gt;. In this case, the index is calculated like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(key.Length - minLength) * MaxPerLength&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;search-algorithm-2&quot;&gt;Search algorithm&lt;/h3&gt;

&lt;p&gt;The search is done in 3 steps (Figure 9):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The bucket is determined in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_lengthBuckets&lt;/code&gt; array.&lt;/li&gt;
  &lt;li&gt;A linear search in the bucket finds the index of the desired key in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_keys&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The value is returned.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image10.png&quot; alt=&quot;Search in LengthBucketsFrozenDictionary&quot; /&gt;
&lt;strong&gt;
Figure 9 – Search in LengthBucketsFrozenDictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LengthBucketsFrozenDictionary&lt;/code&gt; has two limitations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The number of keys with the same length must not exceed &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaxPerLength&lt;/code&gt; (&lt;a href=&quot;https://en.wikipedia.org/wiki/Pigeonhole_principle&quot;&gt;Pigeonhole Principle&lt;/a&gt;). You can’t place 6 strings of the same length in a bucket with a capacity of 5 elements.&lt;/li&gt;
  &lt;li&gt;The number of empty buckets must be less than 20%. Otherwise, the implementation becomes inefficient in terms of memory usage.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If either of these conditions is not met, one of the &lt;a href=&quot;https://github.com/dotnet/runtime/blob/e75fc2775a2c844ffd45e64b9a1b67b7e088959f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs&quot;&gt;OrdinalStringFrozenDictionary&lt;/a&gt; implementations will be chosen (more on that later).&lt;/p&gt;

&lt;h3 id=&quot;benchmark-2&quot;&gt;Benchmark&lt;/h3&gt;

&lt;p&gt;The benchmark results show that reading from a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LengthBucketsFrozenDictionary&lt;/code&gt; can be up to 99% faster than a regular &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;. However, if the dictionary has 5 or more keys with the same length, the performance of small dictionaries (up to 100 items) can be worse (see Figure 10).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image11.png&quot; alt=&quot;Reading speed LengthBucketsFrozenDictionary comparing to Dictionary&quot; /&gt;
&lt;strong&gt;
Figure 10 – Reading speed LengthBucketsFrozenDictionary comparing to Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;group-4-dictionary-with-string-keys&quot;&gt;Group 4. Dictionary with string keys&lt;/h2&gt;

&lt;p&gt;As we already know, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LengthBucketsFrozenDictionary&lt;/code&gt; has limitations. When it’s not possible to distribute keys into buckets, one of 11 implementations of the abstract class &lt;a href=&quot;https://github.com/dotnet/runtime/blob/e75fc2775a2c844ffd45e64b9a1b67b7e088959f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs&quot;&gt;OrdinalStringFrozenDictionary&lt;/a&gt; is used. All of them use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenHashTable&lt;/code&gt;, but differ in the &lt;a href=&quot;https://github.com/dotnet/runtime/blob/0378936909464c84cf207ffd1a21efa474fc34c0/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/Hashing.cs&quot;&gt;algorithm for calculating the string’s hash code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The choice of the optimal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrdinalStringFrozenDictionary&lt;/code&gt; implementation depends on the key analysis by the &lt;a href=&quot;https://github.com/dotnet/runtime/blob/d25d42e6dba95016cc1af95367a50c6b8b26efdd/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/KeyAnalyzer.cs&quot;&gt;KeyAnalyzer class&lt;/a&gt;. In turn, the result of the analysis depends on key length, the presence of non-ASCII characters, specified &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.stringcomparison&quot;&gt;string comparison&lt;/a&gt; rules and the presence of unique substrings in the keys.&lt;/p&gt;

&lt;p&gt;Obviously, the longer the string, the slower the hash code calculation. Therefore, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KeyAnalyzer&lt;/code&gt; tries to find the shortest substrings that allow the key to be uniquely identified. To better understand this, let’s revisit the example with fruits: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apple&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grape&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fig&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lime&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lemon&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kiwi&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KeyAnalyzer&lt;/code&gt; analyzes substrings of length 1 with left-aligned keys (see Figure 11).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image12.png&quot; alt=&quot;Single-char substrings with left and right algnment&quot; /&gt;
&lt;strong&gt;
Figure 11 – Single-char substrings with left and right algnment
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In this example, with left-aligned keys, there are repeating substrings. For instance, the 0th character of “lime” and “lemon” is the same, as well as the 1st character of “fig” and “lime” and the 2nd character of “lime” and “lemon.” This means that it is impossible to uniquely identify a key by a single character with such alignment. Therefore, the search for a substring continues with right-aligned keys. In this case, the substrings will be unique when using the 2nd or 1st character from the end. Knowing the alignment, starting index, and length of the substring, the string can be uniquely identified by calculating the hash code of its substring.&lt;/p&gt;

&lt;p&gt;If there are no unique substrings of length 1, the search will continue for substrings of 2 characters, 3 characters, and so on, up to the maximum substring length. This value is calculated as the minimum between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minLength&lt;/code&gt; (the shortest key length) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaxSubstringLengthLimit&lt;/code&gt; = 8. This limitation is specifically set to avoid analyzing long substrings, as using them doesn’t improve performance.&lt;/p&gt;

&lt;p&gt;If there is no unique substrings at all, the hash code will be calculated for the entire string.&lt;/p&gt;

&lt;p&gt;In addition to the presence of unique substrings, the implementation is also &lt;a href=&quot;https://github.com/dotnet/runtime/blob/0378936909464c84cf207ffd1a21efa474fc34c0/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/KeyAnalyzer.cs#L56&quot;&gt;affected by the specified string comparison&lt;/a&gt; parameters and the presence of non-ASCII characters. Based on these parameters, a more optimal comparator will be chosen.&lt;/p&gt;

&lt;h3 id=&quot;search-algorithm-3&quot;&gt;Search algorithm&lt;/h3&gt;

&lt;p&gt;Search in dictionaries based on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrdinalStringFrozenDictionary&lt;/code&gt; is &lt;a href=&quot;https://github.com/dotnet/runtime/blob/98b165db27a3c15b9c0df208d1acca573b3dd15e/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs#L83&quot;&gt;performed as follows&lt;/a&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, it checks whether the key length is within the acceptable range. This allows for quickly discarding keys that clearly do not match due to their length.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Next, the same steps that we’ve seen earlier in other dictionaries with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenHashTable&lt;/code&gt; are performed. The hash code of the substring is calculated, and a search is performed in the hash table. In case of a collision, a linear search is performed.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;benchmark-3&quot;&gt;Benchmark&lt;/h3&gt;

&lt;p&gt;According to the benchmark results, a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; with up to 75,000 elements is faster than a regular &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;. However, as the dictionary size increases, the search speed becomes worse (see Figure 12).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image13.png&quot; alt=&quot;Reading speed from OrdinalStringFrozenDictionary_LeftJustifiedSubstring comparing to Dictionary&quot; /&gt;
&lt;strong&gt;
Рисунок 12 – Reading speed from OrdinalStringFrozenDictionary_LeftJustifiedSubstring comparing to Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The high speed of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; is due to the fast hash code calculation of keys. The algorithm used in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; is 75% to 90% faster than the one in a regular &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt; (see Figure 13).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image14.png&quot; alt=&quot;FrozenDictionary and Dictionary hash calculation speed&quot; /&gt;
&lt;strong&gt;
Figure 13 – Hash calculation speed
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The performance drop in dictionaries with 75,000 elements or more is caused by the increasing number of hash collisions as the dictionary size grows (see Figure 14).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image15.png&quot; alt=&quot;FrozenDictionary and Dictinoary hash collisions count&quot; /&gt;
&lt;strong&gt;
Figure 14 – Hash collisions count
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As shown in the figures, the algorithm used in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; significantly speeds up hash code calculation, improving performance by up to 70%. However, this approach negatively impacts search performance in relatively large dictionaries.&lt;/p&gt;

&lt;h2 id=&quot;group-5-small-dictionaries&quot;&gt;Group 5. Small dictionaries&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeComparableFrozenDictionary&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeDefaultComparerFrozenDictionary&lt;/code&gt; are used when the original dictionary has no more than 10 elements, while &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallFrozenDictionary&lt;/code&gt; is used when it has no more than 4 elements. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeComparableFrozenDictionary&lt;/code&gt; is applied if the key type is a &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8e92aef5387fe1d4b9159b4a3657416ac7d0a05a/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/Constants.cs#L44&quot;&gt;built-in primitive value type&lt;/a&gt; (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;double&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enum&lt;/code&gt;, etc.). If the key type is a custom structure, then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeDefaultComparerFrozenDictionary&lt;/code&gt; will be used. Developers on .NET explain this by noting that built-in types always implement the IComparable interface, allowing for a slight optimization in search by sorting the key and value arrays in advance.&lt;/p&gt;

&lt;h3 id=&quot;search-algorithm-4&quot;&gt;Search algorithm&lt;/h3&gt;

&lt;p&gt;Strictly speaking, the classes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeComparableFrozenDictionary&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeDefaultComparerFrozenDictionary&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallFrozenDictionary&lt;/code&gt; are not hash tables. The search for a value in these classes is performed using a simple linear search via a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; loop (Figure 15).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image16.png&quot; alt=&quot;Search in SmallValueTypeComparableFrozenDictionary&quot; /&gt;
&lt;strong&gt;
Figure 15 – Search in SmallValueTypeComparableFrozenDictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeComparableFrozenDictionary&lt;/code&gt;, since the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_keys&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_values&lt;/code&gt; arrays are sorted, the search can continue as long as the searched key is greater than the current value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_keys[i]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The implementations of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeDefaultComparerFrozenDictionary&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallFrozenDictionary&lt;/code&gt; are similar to the previous one, except that sorting is not used. Therefore, a linear search through the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_keys&lt;/code&gt; array will always be performed.&lt;/p&gt;

&lt;h3 id=&quot;benchmark-4&quot;&gt;Benchmark&lt;/h3&gt;

&lt;p&gt;Despite all the optimizations in these classes, the benchmark results do not look impressive (see Figure 16). Even the slight speedup that these classes can provide amounts to just a few tens of nanoseconds.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/10/2024-10-09-frozen-dictionary/image17.png&quot; alt=&quot;Reading speed from SmallValueTypeComparableFrozenDictionary, SmallValueTypeDefaultComparerFrozenDictionary and SmallFrozenDictionary comparing to Dictionary&quot; /&gt;
&lt;strong&gt;
Figure 16 – Reading speed from SmallValueTypeComparableFrozenDictionary, SmallValueTypeDefaultComparerFrozenDictionary and SmallFrozenDictionary comparing to Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this article, I tried to explain the main implementation features of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt;. We made sure that in most cases &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; is faster than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Actually, there are lots of another algorithms and optimizations. For example, usage of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayPool&lt;/code&gt;, fast algorithm for modulus calculation, integer array with bit shift instead of boolean array etc. It would be impossible to do more detailed analysis in a single article. But from time to time I make such posts in my &lt;a href=&quot;https://t.me/yet_another_dev&quot;&gt;Telegram channel&lt;/a&gt;. If you are interested, I will be glad to see you among the readers.&lt;/p&gt;</content><author><name>© 2024 Alexey Fedorov</name><email>your-email@domain.com</email></author><category term="csharp" /><category term="frozendictionary" /><category term="dictionary" /><category term="performance" /><category term="benchmark" /><category term="hashtable" /><category term="algorithms" /><summary type="html">With .NET 8 release, C# developers received a new type of generic collections – FrozenDictionary. The main feature of this dictionary is that it’s immutable, but allows reading the data faster comparing to a plain Dictionary. I split the results on the cover by a reason: the algorithms used in FrozenDictionary are highly depended on key type, the size of the array or even the number of the string keys with the same length. In this article, we’ll look into details how fast is FrozenDictionary and why. Version in Russian is here Версия на русском тут.</summary></entry><entry><title type="html">Как данные влияют на производительность</title><link href="http://www.alexeyfv.xyz//2024/09/30/how-data-affects-performance.html" rel="alternate" type="text/html" title="Как данные влияют на производительность" /><published>2024-09-30T00:00:00+00:00</published><updated>2024-09-30T00:00:00+00:00</updated><id>http://www.alexeyfv.xyz//2024/09/30/how-data-affects-performance</id><content type="html" xml:base="http://www.alexeyfv.xyz//2024/09/30/how-data-affects-performance.html">&lt;p&gt;Хочу рассказать о том, насколько важно способ инициализации данных для достижения максимальной производительности кода.&lt;/p&gt;

&lt;p&gt;Рассмотрим следующий синтетический пример.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-30-how-data-affects-performance/image01.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Массивы t1 и t2 содержат информацию о транзакциях.&lt;/li&gt;
  &lt;li&gt;Два метода, Setup1 и Setup2, инициализируют массивы t1 и t2 соответственно: Setup1 – двумя циклами for, а Setup2 – одним.&lt;/li&gt;
  &lt;li&gt;Метод Sum позволяет вычислить сумму транзакций в массивах t1 или t2.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вопрос: при каком способе инициализации расчёт суммы в массивах Sum(t1) + Sum(t2) выполнится быстрее?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Правильный ответ: Sum(t1) + Sum(t2) рассчитывается быстрее, если массивы инициализировать двумя циклами for.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-30-how-data-affects-performance/image02.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Почему так? Всё дело в кэше данных процессора. Я уже писал пост на эту тему, но тогда рассматривал два разных алгоритма для обхода одной и той же матрицы. В данном случае алгоритм не меняется, но данные инициализируются по-разному.&lt;/p&gt;

&lt;p&gt;Если массивы t1 и t2 инициализировать одним циклом for, то в памяти это выглядит примерно так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;t1[0], t2[0], t1[1], t2[1], t1[2], t2[3], ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;При расчёте, например, Sum(t1), в самом начале происходит обращение к элементу t1[0]. Копирование данных из памяти в кэш происходит блоками по 64 байта — это размер линии кэша большинства современных процессоров. Из-за этого в кэш попадают элементы массива t2, хотя методу Sum нужны элементы только одного массива. В результате увеличивается количество промахов кэша.&lt;/p&gt;

&lt;p&gt;Если массивы t1 и t2 инициализировать двумя циклами for, то локальность данных более высокая, что снижает количество промахов кэша:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;t1[0], t1[1], t1[2], t1[3], ... t2[0], t2[1], t2[2], t2[3], ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>© 2024 Alexey Fedorov</name><email>your-email@domain.com</email></author><category term="csharp" /><category term="performance" /><category term="benchmark" /><summary type="html">Хочу рассказать о том, насколько важно способ инициализации данных для достижения максимальной производительности кода. Рассмотрим следующий синтетический пример. Массивы t1 и t2 содержат информацию о транзакциях. Два метода, Setup1 и Setup2, инициализируют массивы t1 и t2 соответственно: Setup1 – двумя циклами for, а Setup2 – одним. Метод Sum позволяет вычислить сумму транзакций в массивах t1 или t2. Вопрос: при каком способе инициализации расчёт суммы в массивах Sum(t1) + Sum(t2) выполнится быстрее?</summary></entry><entry><title type="html">Как ошибки в бенчмарке могут привести к неправильным выводам</title><link href="http://www.alexeyfv.xyz//2024/09/16/bad-vs-better-benchmark.html" rel="alternate" type="text/html" title="Как ошибки в бенчмарке могут привести к неправильным выводам" /><published>2024-09-16T00:00:00+00:00</published><updated>2024-09-16T00:00:00+00:00</updated><id>http://www.alexeyfv.xyz//2024/09/16/bad-vs-better-benchmark</id><content type="html" xml:base="http://www.alexeyfv.xyz//2024/09/16/bad-vs-better-benchmark.html">&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-16-bad-vs-better-benchmark/image01.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Видел я однажды &lt;a href=&quot;https://www.linkedin.com/posts/sa-es-ir_csharp-dotnet-forloops-activity-7188563012553773056-K0z0&quot;&gt;пост в LinkedIn&lt;/a&gt;, заголовок которого утверждал, что .NET 9 медленнее, чем .NET 8. Сильное заявление. Проверять я его конечно буду. Ведь я сам большой любитель замеров производительности. Перейдём сразу к тому, что не так с &lt;a href=&quot;https://github.com/sa-es-ir/ForLoopComparison&quot;&gt;бенчмарком&lt;/a&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;❌ Методы не возвращают результат&lt;/p&gt;

&lt;p&gt;Современные компиляторы умные. Они могут понять, когда выполняемый код не влияет на результат программы, и просто удаляют его. Такая оптимизация называется &lt;a href=&quot;https://en.wikipedia.org/wiki/Dead-code_elimination&quot;&gt;dead-code elimination&lt;/a&gt; (DCE). В данном случае, метод &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DoSomeThing&lt;/code&gt; фактически не делает ничего, поэтому компилятор удаляет его в методе &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;For&lt;/code&gt;. Но в методе &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForEach_Linq&lt;/code&gt; такое сделать нельзя, т.к. в нём создаётся делегат. В результате получается сравнение методов с разным поведением (рисунок 2).&lt;/p&gt;

&lt;p&gt;✅ Всегда возвращайте результат из методов&lt;/p&gt;

&lt;p&gt;Исправленный вариант может выглядеть так. Нам неважно, что будет в переменной sum. Главное, что её использование предотвращает DCE и не оказывает значительного влияния на результаты бенчмарка.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-16-bad-vs-better-benchmark/image02.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;p&gt;❌ Слепое сравнивание foreach&lt;/p&gt;

&lt;p&gt;Как мы знаем, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foreach&lt;/code&gt; предназначен для итерации по коллекциям, которые возвращают &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Enumerator&lt;/code&gt;. Но даже если коллекция возвращает &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Enumerator&lt;/code&gt;, это не гарантирует, что он будет использоваться. Рассмотрим &lt;a href=&quot;https://sharplab.io/#gist:c3a7b45510a9bfe1d34f11677f0af5b5&quot;&gt;пример&lt;/a&gt; на рисунке 3:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foreach&lt;/code&gt; с массивом будет преобразован в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; c индексаторов;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foreach&lt;/code&gt; со списком – в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;int&amp;gt;.Enumerator&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foreach&lt;/code&gt; с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ICollection&amp;lt;int&amp;gt;&lt;/code&gt; – в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IEnumerator&amp;lt;int&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✅ Сравнивать производительность foreach нужно с разными типами&lt;/p&gt;

&lt;p&gt;Поскольку &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foreach&lt;/code&gt; компилируется в различный код в зависимости от коллекции, производительность может значительно отличаться. Поэтому важно сравнивать каждый тип отдельно. Не исключаю, что эта деталь реализации может измениться в будущем.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-16-bad-vs-better-benchmark/image03.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;p&gt;❌ Передача метода в виде параметра&lt;/p&gt;

&lt;p&gt;При передаче метода в виде параметра создаётся делегат. В нашем примере – &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Action&amp;lt;int&amp;gt;&lt;/code&gt; (рисунок 4). Делегат, как известно ссылочный тип, то есть его создание – аллокация памяти, которая влияет на результаты бечмарка.&lt;/p&gt;

&lt;p&gt;✅ При передаче метода в виде параметра нужно заранее создать экземпляр делегата&lt;/p&gt;

&lt;p&gt;Правильнее было бы проинициализировать делегат в методе &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GlobalSetup&lt;/code&gt;, который выполняется перед бенчмарками.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-16-bad-vs-better-benchmark/image04.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Теперь посмотрим на результаты &lt;a href=&quot;https://github.com/alexeyfv/for-benchmark&quot;&gt;исправленного бенчмарка&lt;/a&gt;. Bad – изначальный бенчмарк, Better – после исправления.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-16-bad-vs-better-benchmark/image05.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В бенчмарке Bad, который я запустил на своём ноутбуке, метод &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForEach_LinqParallel&lt;/code&gt; отработал на .NET 9 чуть быстрее, чем на .NET 8. То есть та разница в, о которой говорил автор, была в рамках погрешности.&lt;/p&gt;

&lt;p&gt;В бенчмарке Better, метод &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForEach_LinqParallel&lt;/code&gt; отработал на .NET 9 медленнее чем на .NET 8 на 90 мкс. Такую разницу я бы тоже отнёс к погрешности и не стал акцентировать внимание.&lt;/p&gt;

&lt;p&gt;В целом, результаты во всех трёх версиях .NET кажутся плюс-минус одинаковыми. Поэтому, я бы не стал заявлять о том, что .NET 9 медленнее .NET 8.&lt;/p&gt;</content><author><name>© 2024 Alexey Fedorov</name><email>your-email@domain.com</email></author><category term="csharp" /><category term="performance" /><category term="benchmark" /><category term="bestpractices" /><summary type="html">Видел я однажды пост в LinkedIn, заголовок которого утверждал, что .NET 9 медленнее, чем .NET 8. Сильное заявление. Проверять я его конечно буду. Ведь я сам большой любитель замеров производительности. Перейдём сразу к тому, что не так с бенчмарком.</summary></entry><entry><title type="html">Как в FrozenDictionary подсчитываются коллизии хэша</title><link href="http://www.alexeyfv.xyz//2024/09/07/frozen-dictionary-collisions-count.html" rel="alternate" type="text/html" title="Как в FrozenDictionary подсчитываются коллизии хэша" /><published>2024-09-07T00:00:00+00:00</published><updated>2024-09-07T00:00:00+00:00</updated><id>http://www.alexeyfv.xyz//2024/09/07/frozen-dictionary-collisions-count</id><content type="html" xml:base="http://www.alexeyfv.xyz//2024/09/07/frozen-dictionary-collisions-count.html">&lt;p&gt;Второй короткий пост о деталях реализации &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt;, которые остались за кадром. Сегодня об &lt;a href=&quot;https://github.com/dotnet/runtime/blob/1c4755daf8f25f067a360c1dcae0d19df989e4e7/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs#L277&quot;&gt;алгоритме подсчёта количества коллизий хэша&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;В &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; хэш-коды всех ключей известны заранее. Это позволяет выбрать такое количество бакетов, при котором число коллизий не превышает допустимый порог — на данный момент это 5%. Делается это следующим образом:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Выбирается количество бакетов n из определённого диапазона. Этот диапазон &lt;a href=&quot;https://github.com/dotnet/runtime/blob/1c4755daf8f25f067a360c1dcae0d19df989e4e7/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs#L177&quot;&gt;подобран разработчиками .NET эвристическим способом&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Для каждого хэш-кода рассчитывается остаток от деления на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; и считается количество одинаковых результатов.&lt;/li&gt;
  &lt;li&gt;Если количество коллизий слишком велико, то &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; увеличивается.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Вот пример с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bool[]&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashCodes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*some hash codes*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seenBuckets&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bucketsNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collisionsCount&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashCodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketIndex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketsCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seenBuckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bucketIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;collisionsCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;seenBuckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bucketIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Но в .NET сделали иначе и вместо &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bool[]&lt;/code&gt; используют &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int[]&lt;/code&gt; с битовыми сдвигами.&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashCodes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*some hash codes*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seenBuckets&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bucketsNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collisionsCount&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashCodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketIndex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketsCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketIndex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seenBuckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;collisionsCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;seenBuckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Такой подход позволяет значительно уменьшить размер массива (20% – 80%) и время его создания уменьшается в среднем на 70%. В то же время, скорость чтения и записи снижается в среднем на 50% и 198% соответственно (см. графики).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-09-frozen-dictionary-collisions-count/image01.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-09-frozen-dictionary-collisions-count/image02.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-09-frozen-dictionary-collisions-count/image03.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-09-frozen-dictionary-collisions-count/image04.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Получается, использование целых чисел с битовым сдвигом – компромиссное решение. Команда .NET видимо посчитала, что аллоцировать меньше памяти важнее, чем скорость алгоритма.&lt;/p&gt;</content><author><name>© 2024 Alexey Fedorov</name><email>your-email@domain.com</email></author><category term="csharp" /><category term="frozendictionary" /><category term="benchmark" /><category term="hashtable" /><category term="algorithms" /><summary type="html">Второй короткий пост о деталях реализации FrozenDictionary, которые остались за кадром. Сегодня об алгоритме подсчёта количества коллизий хэша.</summary></entry><entry><title type="html">Создание массивов в C#: способы и производительность</title><link href="http://www.alexeyfv.xyz//2024/09/05/create-array.html" rel="alternate" type="text/html" title="Создание массивов в C#: способы и производительность" /><published>2024-09-05T00:00:00+00:00</published><updated>2024-09-05T00:00:00+00:00</updated><id>http://www.alexeyfv.xyz//2024/09/05/create-array</id><content type="html" xml:base="http://www.alexeyfv.xyz//2024/09/05/create-array.html">&lt;p&gt;Как создать массив в C#? Вопрос кажется простым. Но с каждой новой версией .NET появляются всё новые и новые фичи. На данный момент я знаю аж 7 способов создания массивов.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new T[]&lt;/code&gt;. Самый очевидный, простой и популярный способ создания объектов и массивов в частности. Этот оператор используется повсеместно и является основным для большинства сценариев.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-05-create-array/image01.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stackalloc T[]&lt;/code&gt;. Выделяет память в стеке для массива заданного размера и возвращает указатель. Когда-то давно оператор stackalloc требовал использования небезопасного (unsafe) контекста. С появлением &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; его можно применять и без unsafe. Этот способ ограничен размером доступной памяти в стеке и при необдуманном использовании может привести к &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StackOverflowException&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-05-create-array/image02.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Для небольших массивов stackalloc T[] быстрее new T[] в среднем на 20% и на 88% для больших массивов. Под небольшими массивами я подразумеваю массивы размером меньше 85 000 байт, т.е. размещаемые в куче малых объектов (SOH), а под большими – в куче больших объектов (LOH).&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt;. ArrayPool выделяет массив из пула, что минимизирует количество аллокаций памяти и уменьшает нагрузку на сборщик мусора. Массивы, возвращаемые из пула, могут быть больше запрошенного размера, например, для массива из 700 элементов будет возвращён массив длиной 1024. Использование пула полезно, для относительно больших временных массивов, которые часто создаются и уничтожаются.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt; быстрее &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new T[]&lt;/code&gt; в среднем на 30% для небольших массивов и на 89% для больших массивов. Однако для массивов размером менее 300–400 байт использование пула может быть медленнее.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-05-create-array/image03.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GC.AllocateUninitializedArray&amp;lt;T&amp;gt;&lt;/code&gt;. Этот метод создаёт массив без инициализации его элементов значениями по умолчанию. Использование этого метода может быть небезопасным, так как массив содержит неинициализированные данные. Обязательно перезаписывайте все значения в созданном массиве.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GC.AllocateUninitializedArray&amp;lt;T&amp;gt;&lt;/code&gt; быстрее &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new T[]&lt;/code&gt; в среднем на 15% для массивов 2048 – 85 000 байт. В остальных случаях производительность с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new T[]&lt;/code&gt; одинаковая.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-05-create-array/image04.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array.Initialize&lt;/code&gt;. Позволяет создавать массивы, задавая тип во время выполнения. Например, когда тип неизвестен на этапе компиляции. Полезно для сценариев, связанных с динамической типизацией.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Производительность аналогична &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new T[]&lt;/code&gt;, либо хуже.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-05-create-array/image05.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InlineArrayAttribute&lt;/code&gt;. Относительно новая фича, появившаяся в C# 12. Позволяет объявить структуру с атрибутом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InlineArray&lt;/code&gt;, которая затем будет вести себя как массив.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Быстрее &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new T[]&lt;/code&gt; в среднем на 39% для небольших массивов и на 91% для больших массивов.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-05-create-array/image06.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collections expressions&lt;/code&gt;. Синтаксический сахар, который позволяет записать массив в виде литерала. Например, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int[] array = [1, 2, 3]&lt;/code&gt; создаёт массив в куче, аналогично использованию &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new T[]&lt;/code&gt;. А конструкция &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Span&amp;lt;int&amp;gt; array = [1, 2, 3]&lt;/code&gt; создаёт массив в стеке, аналогично &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stackalloc&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/09/2024-09-05-create-array/image07.png&quot; alt=&quot;content&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Код бенчмарка и результаты &lt;a href=&quot;https://github.com/alexeyfv/create-array&quot;&gt;тут&lt;/a&gt;.&lt;/p&gt;</content><author><name>© 2024 Alexey Fedorov</name><email>your-email@domain.com</email></author><category term="csharp" /><category term="performance" /><category term="benchmark" /><category term="array" /><summary type="html">Как создать массив в C#? Вопрос кажется простым. Но с каждой новой версией .NET появляются всё новые и новые фичи. На данный момент я знаю аж 7 способов создания массивов.</summary></entry><entry><title type="html">Быстрый расчёт остатка от деления</title><link href="http://www.alexeyfv.xyz//2024/08/29/fast-mod-algorithm.html" rel="alternate" type="text/html" title="Быстрый расчёт остатка от деления" /><published>2024-08-29T00:00:00+00:00</published><updated>2024-08-29T00:00:00+00:00</updated><id>http://www.alexeyfv.xyz//2024/08/29/fast-mod-algorithm</id><content type="html" xml:base="http://www.alexeyfv.xyz//2024/08/29/fast-mod-algorithm.html">&lt;p&gt;В процессе работы над &lt;a href=&quot;/2024/08/22/frozen-dictionary.html&quot;&gt;статьёй про FrozenDictionary&lt;/a&gt; заметил немало интересных деталей, о которых хочется рассказать. Начнём с простого, поэтому сегодня о быстром алгоритме расчёта остатка от деления.&lt;/p&gt;

&lt;p&gt;Как известно, индекс бакета в словаре рассчитывается как остаток от деления &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashCode&lt;/code&gt; на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bucketsCount&lt;/code&gt;. В C# и многих других языках программирования для этого используется оператор &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketNum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashCode&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketsCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В общем случае, эта операция включает в себя деление, которое &lt;a href=&quot;https://stackoverflow.com/questions/15745819/why-is-division-more-expensive-than-multiplication&quot;&gt;выполняется медленнее&lt;/a&gt;, чем другие арифметические операции. Поэтому была придумана следующая формула:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FastModLemier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiplier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketsNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)((((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UInt128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hashcode&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiplier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketsNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Идея этого подхода в том, что если количество бакетов известно заранее, то можно вычислить значение &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multiplier&lt;/code&gt; по формуле &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ulong.MaxValue / bucketsNum + 1&lt;/code&gt;. Это позволяет заменить деление на умножение и битовые сдвиги. Если интересны подробности и математическое обоснование формулы, то можете ознакомиться со &lt;a href=&quot;https://r-libre.teluq.ca/1633/1/Faster_Remainder_of_the_Division_by_a_Constant.pdf&quot;&gt;статьёй Дэниела Лемира&lt;/a&gt;, разработчика данного метода. Для общего понимания достаточно прочитать главы 1 и 3.2.&lt;/p&gt;

&lt;p&gt;В &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt; используется другой вариант &lt;a href=&quot;https://github.com/dotnet/runtime/blob/2aca5e53dba1a620ae5b57972c355eebed0cdb08/src/libraries/System.Private.CoreLib/src/System/Collections/HashHelpers.cs#L99&quot;&gt;формулы&lt;/a&gt;, который, по &lt;a href=&quot;https://github.com/dotnet/runtime/pull/406&quot;&gt;словам разработчиков Microsoft&lt;/a&gt; немного быстрее, что подтверждается результатами бенчмарка (рисунок 1):&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FastModDotNet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiplier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketsNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(((((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;multiplier&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bucketsNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Кроме того, JIT-компилятор способен оптимизировать код и заменить деление на несколько операций умножения и битовый сдвиг, если значение bucketsCount известно на этапе компиляции. В результате ASM-код для DefaultModConst будет идентичен коду FastModDotNet (рисунок 2).&lt;/p&gt;

&lt;p&gt;Код бенчмарка и результаты &lt;a href=&quot;https://github.com/alexeyfv/fastmod&quot;&gt;тут&lt;/a&gt;.&lt;/p&gt;</content><author><name>© 2024 Alexey Fedorov</name><email>your-email@domain.com</email></author><category term="csharp" /><category term="performance" /><category term="benchmark" /><category term="hashcode" /><category term="hashtable" /><category term="algorithms" /><summary type="html">В процессе работы над статьёй про FrozenDictionary заметил немало интересных деталей, о которых хочется рассказать. Начнём с простого, поэтому сегодня о быстром алгоритме расчёта остатка от деления.</summary></entry><entry><title type="html">Заглядываем под капот FrozenDictionary: насколько он быстрее Dictionary и почему</title><link href="http://www.alexeyfv.xyz//2024/08/22/frozen-dictionary.html" rel="alternate" type="text/html" title="Заглядываем под капот FrozenDictionary: насколько он быстрее Dictionary и почему" /><published>2024-08-22T00:00:00+00:00</published><updated>2024-08-22T00:00:00+00:00</updated><id>http://www.alexeyfv.xyz//2024/08/22/frozen-dictionary</id><content type="html" xml:base="http://www.alexeyfv.xyz//2024/08/22/frozen-dictionary.html">&lt;p&gt;С &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8/runtime\#performance-focused-types&quot;&gt;релизом .NET 8&lt;/a&gt; в арсенале C# разработчиков появилась новая коллекция – &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt;. Особенность этого словаря в том, что он неизменяемый, но при этом обеспечивает более быстрое чтение по сравнению с обычным &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;. Я неспроста разбил результаты на обложке по типам – используемые во &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictinoary&lt;/code&gt; алгоритмы сильно зависят от типа ключа, размера словаря или даже, например, количества строковых ключей одинаковой длины. В этой статье подробно разберем, насколько &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; быстрее и почему.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image01.png&quot; alt=&quot;Производительность FrozenDictionary по сравнению с Dictionary&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;English version is &lt;a href=&quot;/2024/10/09/frozen-dictionary.html&quot;&gt;here&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;оглавление&quot;&gt;Оглавление&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#оглавление&quot;&gt;Оглавление&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dictionary-ты-один-приходи-мы-тоже-один-придём&quot;&gt;Dictionary, ты один приходи. Мы тоже один придём&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#дисклеймер&quot;&gt;Дисклеймер&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#группа-1-словари-по-умолчанию&quot;&gt;Группа 1. Словари по умолчанию&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#алгоритм-поиска&quot;&gt;Алгоритм поиска&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#бенчмарк&quot;&gt;Бенчмарк&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#группа-2-словарь-для-ключей-типа-int32&quot;&gt;Группа 2. Словарь для ключей типа Int32&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#алгоритм-поиска-1&quot;&gt;Алгоритм поиска&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#бенчмарк-1&quot;&gt;Бенчмарк&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#группа-3-словарь-с-алгоритмом-распределения-строк-по-длине&quot;&gt;Группа 3. Словарь с алгоритмом распределения строк по длине&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#алгоритм-поиска-2&quot;&gt;Алгоритм поиска&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#бенчмарк-2&quot;&gt;Бенчмарк&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#группа-4-словари-с-ключом-типа-string&quot;&gt;Группа 4. Словари с ключом типа string&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#алгоритм-поиска-3&quot;&gt;Алгоритм поиска&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#бенчмарк-3&quot;&gt;Бенчмарк&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#группа-5-небольшие-словари&quot;&gt;Группа 5. Небольшие словари&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#алгоритм-поиска-4&quot;&gt;Алгоритм поиска&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#бенчмарк-4&quot;&gt;Бенчмарк&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#резюме&quot;&gt;Резюме&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dictionary-ты-один-приходи-мы-тоже-один-придём&quot;&gt;Dictionary, ты один приходи. Мы тоже один придём&lt;/h2&gt;

&lt;p&gt;Прежде чем начать &lt;del&gt;битву&lt;/del&gt; сравнение с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;, важно заметить, что &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; – это абстрактный класс с &lt;a href=&quot;https://github.com/dotnet/runtime/tree/51e99e12a8a09c69e30fdcb004facf68f73173a6/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen&quot;&gt;множеством реализаций&lt;/a&gt;. Точнее, их 18. Вместо объяснений, когда какая реализация используется, проще показать на схеме, поэтому смотрим рисунок 1.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image02.png&quot; alt=&quot;Выбор реализации FrozenDictionary&quot; /&gt;
&lt;strong&gt;Рисунок 1 – Выбор реализации FrozenDictionary&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Пугаться не стоит, реализации можно разделить на 5 групп по принципу работы:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;В &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/DefaultFrozenDictionary.cs&quot;&gt;DefaultFrozenDictionary&lt;/a&gt; и &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/ValueTypeDefaultComparerFrozenDictionary.cs&quot;&gt;ValueTypeDefaultComparerFrozenDictionary&lt;/a&gt; используется структура &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs&quot;&gt;FrozenHashTable&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;В Int32FrozenDictionary тоже используется FrozenHashTable, но нет расчёта хэш-кода, поскольку значение ключа и есть хэш-код.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/LengthBucketsFrozenDictionary.cs&quot;&gt;LengthBucketsFrozenDictionary&lt;/a&gt; использует алгоритм, похожий на &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0&quot;&gt;блочную сортировку&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Реализации &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs&quot;&gt;OrdinalStringFrozenDictionary&lt;/a&gt; тоже используют FrozenHashTable, но в них особенный алгоритм расчёт хэш-кода.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallValueTypeComparableFrozenDictionary.cs\#L18&quot;&gt;SmallValueTypeComparableFrozenDictionary&lt;/a&gt;, &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallValueTypeDefaultComparerFrozenDictionary.cs\#L12&quot;&gt;SmallValueTypeDefaultComparerFrozenDictionary&lt;/a&gt; и &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallFrozenDictionary.cs\#L18&quot;&gt;SmallFrozenDictionary&lt;/a&gt; используют линейный поиск, так как размер словарей не превышает 10 элементов.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Выбор подходящей реализации зависит от множества параметров и происходит в методе &lt;a href=&quot;https://github.com/dotnet/runtime/blob/51e99e12a8a09c69e30fdcb004facf68f73173a6/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenDictionary.cs\#L113&quot;&gt;CreateFromDictionary статического класса FrozenDictionary&lt;/a&gt;. Теперь подробно рассмотрим каждую группу по отдельности, изучим их алгоритмы и сделаем замеры.&lt;/p&gt;

&lt;h2 id=&quot;дисклеймер&quot;&gt;Дисклеймер&lt;/h2&gt;

&lt;p&gt;Результаты бенчмарков в этой статье очень условны и верны только при определённых условиях. Допускаю, что бенчмарк может показать другие результаты на другом ПК, с другим ЦП, с другим компилятором или при другом сценарии использования рассматриваемого функционала языка. Всегда проверяйте ваш код на конкретно вашем железе и не полагайтесь лишь на статьи из интернета.&lt;/p&gt;

&lt;p&gt;Исходный код бенчмарков и сырые данные результатов можно найти в &lt;a href=&quot;https://github.com/alexeyfv/frozen-dictionary&quot;&gt;этом репозитории&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;группа-1-словари-по-умолчанию&quot;&gt;Группа 1. Словари по умолчанию&lt;/h2&gt;

&lt;p&gt;Как уже было сказано ранее, в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefaultFrozenDictionary&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ValueTypeDefaultComparerFrozenDictionary&lt;/code&gt; используется структура &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenHashTable&lt;/code&gt;. Эта структура, как можно догадаться из названия, представляет собой реализацию хэш-таблицы. Чтобы лучше понять, чем алгоритм в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenHashTable&lt;/code&gt; отличается от &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;, кратко вспомним, как устроен поиск в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;. Если вы это помните, то можете пропустить объяснение.&lt;/p&gt;

&lt;p&gt;Предположим, у нас есть следующий словарь:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;APPLE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;grape&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;GRAPE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lemon&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;LEMON&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fig&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;FIG&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;LIME&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;kiwi&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;KIWI&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;record&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Когда, например, мы ищем значение для ключа &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fruit(&quot;fig&quot;)&lt;/code&gt;, в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt; происходит следующее (рисунок 2):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Вычисляется хэш код ключа &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Рассчитывается индекса бакета &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bucketIndex&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Если ключ в бакете равен искомому, то возвращается значение. Иначе переходим к следующему ключу с таким же хэш-кодом и повторяем п. 3.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image03.png&quot; alt=&quot;Как осуществляется поиск элементов в Dictionary&quot; /&gt;
&lt;strong&gt;Рисунок 2 – Пример поиска в Dictionary&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;алгоритм-поиска&quot;&gt;Алгоритм поиска&lt;/h3&gt;

&lt;p&gt;Иммутабельность &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; позволяет иначе реализовать работу с бакетами в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenHashTable&lt;/code&gt;. Поскольку количество пар ключ-значение не меняется, то можно:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/runtime/blob/c788546f9ad43ea17981d5dc9343b00b6f76d98f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs\#L47&quot;&gt;Подобрать&lt;/a&gt; количество бакетов так, что количество коллизий будет &lt;a href=&quot;https://github.com/dotnet/runtime/blob/3eba70227be23baee21c13a7ab9316d58d469b82/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs\#L151&quot;&gt;не более 5%&lt;/a&gt; от количества уникальных хэшей.&lt;/li&gt;
  &lt;li&gt;Разместить ключи и значения последовательно в массивах &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_keys&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_values&lt;/code&gt;, вместо связного списка в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;. Это сделает поиск более эффективным за счет более высокой локальности данных.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;При использовании &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; поиск значения для ключа &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fruit(&quot;fig&quot;)&lt;/code&gt; выглядел бы следующим образом (рисунок 3):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Вычисляется хэш код ключа &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Рассчитывается индекса бакета &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bucketIndex&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;В массиве &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bucket&lt;/code&gt; получаем значения &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt;, задающие границы в массиве &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashCodes&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Итерируем массив &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashCodes&lt;/code&gt; от &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; до &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt;, в поисках искомого ключа и возвращаем значение при нахождении.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image04.png&quot; alt=&quot;Как осуществляется поиск в DefaultFrozenDictionary&quot; /&gt;
&lt;strong&gt;
Рисунок 3 – Пример поиска в DefaultFrozenDictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;бенчмарк&quot;&gt;Бенчмарк&lt;/h3&gt;

&lt;p&gt;Результаты бенчмарков для &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefaultFrozenDictionary&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ValueTypeDefaultComparerFrozenDictionary&lt;/code&gt; на рисунках 4 и 5.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image05.png&quot; alt=&quot;Скорость чтения из ValueTypeDefaultComparerFrozenDictionary по сравнению с Dictionary&quot; /&gt;
&lt;strong&gt;
Рисунок 4 – Скорость чтения из ValueTypeDefaultComparerFrozenDictionary по сравнению с Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image06.png&quot; alt=&quot;Скорость чтения из DefaultFrozenDictionary по сравнению с Dictionary&quot; /&gt;
&lt;strong&gt;
Рисунок 5 – Скорость чтения из DefaultFrozenDictionary по сравнению с Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Высокая скорость поиска в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt; по сравнению с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ValueTypeDefaultComparerFrozenDictionary&lt;/code&gt; при размере словаря до 1000 элементов, вероятно, связана с агрессивным &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%92%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9&quot;&gt;инлайном&lt;/a&gt; методов &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;. Почему граница именно в 1000 элементов я понять не смог, т.к. в &lt;a href=&quot;https://github.com/dotnet/runtime/blob/10107d3ca202bf1fda76a1bf575d782be4be27c3/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs&quot;&gt;исходном коде&lt;/a&gt; ничего об этом нет. Возможно это детали реализации JIT-компилятора. Если у вас есть идеи на этот счет, поделитесь в комментариях.&lt;/p&gt;

&lt;p&gt;В остальных случаях, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; быстрее на 31-32% для значимых типов и 17-18% для ссылочных типов.&lt;/p&gt;

&lt;h2 id=&quot;группа-2-словарь-для-ключей-типа-int32&quot;&gt;Группа 2. Словарь для ключей типа Int32&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int32FrozenDictionary&lt;/code&gt; также использует &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenHashTable&lt;/code&gt;. Особенность этой реализации в том, что если тип ключа – целое число, то его хэш равен его значению и коллизии в таком словаре не возможны в принципе. Нельзя, например, добавить 2 элемента с ключом 123 – будет выброшено исключение.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// System.ArgumentException: An item with the same key has already been added.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;алгоритм-поиска-1&quot;&gt;Алгоритм поиска&lt;/h3&gt;

&lt;p&gt;Такая особенность &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int32FrozenDictionary&lt;/code&gt; позволяет при чтении пропустить расчёт хэша и &lt;a href=&quot;https://github.com/dotnet/runtime/blob/eb455ec34c6709e487c19e52c29ec712a6fa4d7f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/Int32/Int32FrozenDictionary.cs\#L35&quot;&gt;использовать значение ключа напрямую&lt;/a&gt;. В итоге, поиск значения выглядит так (рисунок 6):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Индекса бакета &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bucketIndex&lt;/code&gt; рассчитывается сразу по значению ключа.&lt;/li&gt;
  &lt;li&gt;В массиве &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bucket&lt;/code&gt; получаем значения &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt;, задающие границы в массиве &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashCodes&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Итерируем массив &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashCodes&lt;/code&gt; от &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; до &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt;, в поисках искомого ключа и возвращаем значение при нахождении.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image07.png&quot; alt=&quot;Как осуществляется поиск в Int32FrozenDictionary&quot; /&gt;
&lt;strong&gt;
Рисунок 6 – Пример поиска в Int32FrozenDictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;бенчмарк-1&quot;&gt;Бенчмарк&lt;/h3&gt;

&lt;p&gt;Благодаря оптимизациям, чтение из &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int32FrozenDictionary&lt;/code&gt; быстрее на 34-42% (рисунок 7).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image08.png&quot; alt=&quot;Скорость чтения из Int32FrozenDictionary по сравнению с Dictionary&quot; /&gt;
&lt;strong&gt;
Рисунок 7 – Скорость чтения из Int32FrozenDictionary по сравнению с Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;группа-3-словарь-с-алгоритмом-распределения-строк-по-длине&quot;&gt;Группа 3. Словарь с алгоритмом распределения строк по длине&lt;/h2&gt;

&lt;p&gt;При создании «замороженных» словарей со строковым ключом, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; в первую очередь попытается создать класс &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LengthBucketsFrozenDictionary&lt;/code&gt;. Этот класс оптимизирован для ситуаций, когда ключи имеют разную длину. Достигается это &lt;a href=&quot;https://github.com/dotnet/runtime/blob/25f82f314b07cc96dd3212ca4ef950b4220516d1/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/LengthBuckets.cs\#L17&quot;&gt;распределением ключей по бакетам&lt;/a&gt;: для каждой уникальной длины ключа создаётся бакет вместимостью &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaxPerLength = 5&lt;/code&gt; элементов. По сути, это реализация &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0&quot;&gt;блочной сортировки&lt;/a&gt;. Чтобы стало понятнее, рассмотрим пример:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;APPLE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;grape&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;GRAPE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lemon&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;LEMON&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fig&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;FIG&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;LIME&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;kiwi&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;KIWI&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frozenDictionary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ToFrozenDictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В словаре есть ключи длиной 3, 4 и 5 символов. Следовательно, их можно распределить в 3 бакета (рисунок 8):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Бакет для ключей длиной 3: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fig&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Бакет для ключей длиной 4: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lime&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kiwi&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Бакет для ключей длиной 5: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apple&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grape&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lemon&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image09.png&quot; alt=&quot;Распределение строк по бакетам на основе их длины&quot; /&gt;
&lt;strong&gt;
Рисунок 8 – Распределение строк по бакетам на основе их длины
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Поскольку известна минимальная (3) и максимальная (5) длина ключей, нет смысла создавать 3 отдельных бакета. Можно всё хранить в одном массиве &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_lengthBuckets&lt;/code&gt;. В таком случае индекс рассчитывается так: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(key.Length - minLength) * MaxPerLength&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;алгоритм-поиска-2&quot;&gt;Алгоритм поиска&lt;/h3&gt;

&lt;p&gt;Поиск осуществляется в 3 шага (рисунок 9):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Определяется бакет в массиве &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_lengthBuckets&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Линейным поиском в бакете определяется индекс искомого ключа в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_keys&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Возвращается значение.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image10.png&quot; alt=&quot;Как осуществляется поиск в LengthBucketsFrozenDictionary&quot; /&gt;
&lt;strong&gt;
Рисунок 9 – Пример поиска в LengthBucketsFrozenDictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;У &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LengthBucketsFrozenDictionary&lt;/code&gt; есть 2 ограничения:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Количество ключей с одинаковой длиной не должно превышать &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaxPerLength&lt;/code&gt; (&lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%94%D0%B8%D1%80%D0%B8%D1%85%D0%BB%D0%B5_(%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D0%B8%D0%BA%D0%B0)&quot;&gt;принцип Дирихле&lt;/a&gt;). Нельзя разместить 6 строк с одинаковой длиной в бакет вместимостью 5 элементов.&lt;/li&gt;
  &lt;li&gt;Количество пустых бакетов должно быть &amp;lt; 20%. Иначе реализация становится неэффективна с точки зрения использования памяти.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Если одно из этих условий не выполняется, то будет выбрана одна из реализаций &lt;a href=&quot;https://github.com/dotnet/runtime/blob/e75fc2775a2c844ffd45e64b9a1b67b7e088959f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs&quot;&gt;OrdinalStringFrozenDictionary&lt;/a&gt; (о ней далее).&lt;/p&gt;

&lt;h3 id=&quot;бенчмарк-2&quot;&gt;Бенчмарк&lt;/h3&gt;

&lt;p&gt;Результаты бенчмарка показывают, что чтение из &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LengthBucketsFrozenDictionary&lt;/code&gt; может быть до 99% быстрее обычного &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;. Но если в словаре количество ключей с одинаковой длиной достигает 5, то производительность небольших словарей (до 100 элементов) может быть хуже (рисунок 10).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image11.png&quot; alt=&quot;Скорость чтения из LengthBucketsFrozenDictionary по сравнению с Dictionary&quot; /&gt;
&lt;strong&gt;
Рисунок 10 – Скорость чтения из LengthBucketsFrozenDictionary по сравнению с Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;группа-4-словари-с-ключом-типа-string&quot;&gt;Группа 4. Словари с ключом типа string&lt;/h2&gt;

&lt;p&gt;Как мы уже знаем, у &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LengthBucketsFrozenDictionary&lt;/code&gt; есть ограничения. Поэтому, если невозможно распределить ключи по бакетам, используется одна из 11 реализаций абстрактного класса &lt;a href=&quot;https://github.com/dotnet/runtime/blob/e75fc2775a2c844ffd45e64b9a1b67b7e088959f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs&quot;&gt;OrdinalStringFrozenDictionary&lt;/a&gt;. Все они используют &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenHashTable&lt;/code&gt;, но отличаются алгоритмом &lt;a href=&quot;https://github.com/dotnet/runtime/blob/0378936909464c84cf207ffd1a21efa474fc34c0/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/Hashing.cs&quot;&gt;расчёта хэш-кода строки&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Выбор оптимальной реализации &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrdinalStringFrozenDictionary&lt;/code&gt; зависит от результата анализа ключей &lt;a href=&quot;https://github.com/dotnet/runtime/blob/d25d42e6dba95016cc1af95367a50c6b8b26efdd/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/KeyAnalyzer.cs&quot;&gt;классом KeyAnalyzer&lt;/a&gt;. На результат влияет длина ключей, наличие не-ASCII символов, заданные правила сравнения строк (&lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.stringcomparison&quot;&gt;StringComparison&lt;/a&gt;) и наличие в ключах уникальных подстрок.&lt;/p&gt;

&lt;p&gt;Очевидно, что чем длиннее строка, тем медленнее выполняется расчёт хэш-кода. Поэтому &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KeyAnalyzer&lt;/code&gt; пытается найти подстроки наименьшей длины, позволяющие однозначно идентифицировать ключ. Для лучшего понимания снова рассмотрим пример с фруктами: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apple&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grape&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fig&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lime&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lemon&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kiwi&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Сперва &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KeyAnalyzer&lt;/code&gt; анализирует подстроки длиной в 1 символ при левостороннем выравнивании ключей (рисунок 11).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image12.png&quot; alt=&quot;Подстроки длиной в 1 символ при левостороннем и правостороннем выравнивании ключей&quot; /&gt;
&lt;strong&gt;
Рисунок 11 – Подстроки длиной в 1 символ при левостороннем и правостороннем выравнивании ключей
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;В нашем примере при левостороннем выравнивании есть повторяющиеся подстроки. Например, 0-й символ lime и lemon, 1-й символ fig и lime и 2-й символ в lime и lemon. То есть невозможно при таком выравнивании однозначно идентифицировать ключ по одному символу. Поэтому поиск подстроки продолжается при правостороннем выравнивании. В этом случае подстроки будут уникальны при использовании 2-го или 1-го символа с конца. Зная выравнивание, индекс начала и длину подстроки можно однозначно идентифицировать строку рассчитав хэш-код её подстроки.&lt;/p&gt;

&lt;p&gt;Если уникальных подстрок длиной в 1 символ нет, то поиск продолжится для подстрок в 2 символа, 3 символа, вплоть до максимальной длины подстроки. Это значение рассчитывается как минимальное между &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minLength&lt;/code&gt; (минимальная длина ключа) и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaxSubstringLengthLimit = 8&lt;/code&gt;. Такое ограничение сделано специально, чтобы не анализировать слишком длинные подстроки, так как их использование не даёт прироста в производительности.&lt;/p&gt;

&lt;p&gt;Если уникальных подстрок нет вообще, то расчёт хэш-кода будет производиться для всей строки.&lt;/p&gt;

&lt;p&gt;Помимо наличия уникальных подстрок на реализацию также &lt;a href=&quot;https://github.com/dotnet/runtime/blob/0378936909464c84cf207ffd1a21efa474fc34c0/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/KeyAnalyzer.cs\#L56&quot;&gt;влияют заданные параметры сравнения строк (StringComparison)&lt;/a&gt; и наличие не-ASCII символов. В зависимости от этих параметров будет выбран более оптимальный компаратор.&lt;/p&gt;

&lt;h3 id=&quot;алгоритм-поиска-3&quot;&gt;Алгоритм поиска&lt;/h3&gt;

&lt;p&gt;Поиск в словарях, основанных на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrdinalStringFrozenDictionary&lt;/code&gt;, происходит &lt;a href=&quot;https://github.com/dotnet/runtime/blob/98b165db27a3c15b9c0df208d1acca573b3dd15e/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs\#L83&quot;&gt;следующим образом&lt;/a&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Проверяется, находится ли длина ключа в пределах допустимого диапазона. Это нужно для быстрого определения ключей, которые явно не подходят по длине.&lt;/li&gt;
  &lt;li&gt;Далее, выполняются те же шаги, что мы ранее видели в других словарях с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenHashTable&lt;/code&gt;. Рассчитывается хэш-код подстроки и осуществляется поиск в хэш-таблице. В случае коллизии осуществляется линейный поиск.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;бенчмарк-3&quot;&gt;Бенчмарк&lt;/h3&gt;

&lt;p&gt;По результатам бенчмарка, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; размером до 75 тыс. элементов быстрее обычного &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;. Однако при дальнейшем увеличении размера словаря скорость поиска снижается (рисунок 12).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image13.png&quot; alt=&quot;Скорость чтения из OrdinalStringFrozenDictionary_LeftJustifiedSubstring по сравнению с Dictionary&quot; /&gt;
&lt;strong&gt;
Рисунок 12 – Скорость чтения из OrdinalStringFrozenDictionary_LeftJustifiedSubstring по сравнению с Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Высокая скорость &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; обусловлена быстрым расчётом хэш-кода ключей. Алгоритм, используемый в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt;, на 75% – 90% быстрее алгоритма обычного &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt; (рисунок 13).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image14.png&quot; alt=&quot;Сравнение скорости расчёта хэша&quot; /&gt;
&lt;strong&gt;
Рисунок 13 – Сравнение скорости расчёта хэша
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Падение производительности в словарях размером 75 тыс. элементов и более вызвано возрастающим количеством коллизий хэша при увеличении размера словаря (рисунок 14).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image15.png&quot; alt=&quot;Количество коллизий при расчёте хэшей&quot; /&gt;
&lt;strong&gt;
Рисунок 14 – Количество коллизий при расчёте хэшей
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Как видно из графиков, алгоритм, используемый в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt;, позволяет ускорить расчёт хэш-кода строки, улучшая производительность до 70%. Однако такой подход негативно сказывается на производительности поиска в относительно больших словарях.&lt;/p&gt;

&lt;h2 id=&quot;группа-5-небольшие-словари&quot;&gt;Группа 5. Небольшие словари&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeComparableFrozenDictionary&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeDefaultComparerFrozenDictionary&lt;/code&gt; используются, когда в исходном словаре не более 10 элементов, а &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallFrozenDictionary&lt;/code&gt; – не более 4-х элементов. При этом, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeComparableFrozenDictionary&lt;/code&gt; применяется, если тип ключа – это &lt;a href=&quot;https://github.com/dotnet/runtime/blob/8e92aef5387fe1d4b9159b4a3657416ac7d0a05a/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/Constants.cs\#L44&quot;&gt;встроенный примитивный значимый тип&lt;/a&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;double&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enum&lt;/code&gt; и т.д.). Если же тип ключа, к примеру, некоторая кастомная структура, то будет использован тип &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeDefaultComparerFrozenDictionary&lt;/code&gt;. Такое разделение разработчики .NET объясняют тем, что у встроенных типов 100% реализован интерфейс IComparable и поэтому можно немного оптимизировать поиск, предварительно отсортировав массивы ключей и значений:&lt;/p&gt;

&lt;h3 id=&quot;алгоритм-поиска-4&quot;&gt;Алгоритм поиска&lt;/h3&gt;

&lt;p&gt;Строго говоря, классы &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeComparableFrozenDictionary&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeDefaultComparerFrozenDictionary&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallFrozenDictionary&lt;/code&gt; – это не хэш-таблицы. Поиск значения в них осуществляется простым линейным поиском через &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; (рисунок 15).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image16.png&quot; alt=&quot;Как осуществляется поиск в SmallValueTypeComparableFrozenDictionary&quot; /&gt;
&lt;strong&gt;
Рисунок 15 – Пример поиска в SmallValueTypeComparableFrozenDictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;В &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeComparableFrozenDictionary&lt;/code&gt;, поскольку массивы &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_keys&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_value&lt;/code&gt; отсортированы, можно осуществлять поиск пока искомое значение ключа больше текущего значения &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_keys[i]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Реализации &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallValueTypeDefaultComparerFrozenDictionary&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SmallFrozenDictionary&lt;/code&gt; похожи на предыдущую, с тем лишь отличием, что в них не используется сортировка. Соответственно, линейный поиск по массиву ключей &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_keys&lt;/code&gt; будет осуществлён всегда.&lt;/p&gt;

&lt;h3 id=&quot;бенчмарк-4&quot;&gt;Бенчмарк&lt;/h3&gt;

&lt;p&gt;Несмотря на все оптимизации в этих классах, результаты бенчмарков не выглядят впечатляющими (рисунок 16). Даже то небольшое ускорение, которое могут дать эти классы, составляет всего лишь несколько десятков наносекунд.
&lt;img src=&quot;/assets/2024/08/2024-08-22-frozen-dictionary/image17.png&quot; alt=&quot;Скорость чтения из SmallValueTypeComparableFrozenDictionary, SmallValueTypeDefaultComparerFrozenDictionary и SmallFrozenDictionary по сравнению с Dictionary&quot; /&gt;
&lt;strong&gt;
Рисунок 16 – Скорость чтения из SmallValueTypeComparableFrozenDictionary, SmallValueTypeDefaultComparerFrozenDictionary и SmallFrozenDictionary по сравнению с Dictionary
&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;резюме&quot;&gt;Резюме&lt;/h2&gt;

&lt;p&gt;В этой статье я постарался разобрать основные моменты, связанные с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt;. Мы убедились, что &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; в большинстве случае действительно быстрее &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;На самом деле, в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FrozenDictionary&lt;/code&gt; применяется ещё множество алгоритмов и оптимизаций. Например, использование пула массивов &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayPool&lt;/code&gt;, оптимизированный алгоритм расчёта остатка от деления, использование массива целых чисел с битовыми сдвигами, вместо массива &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bool&lt;/code&gt; и т.д. Разбор всех деталей не получилось бы сделать в рамках одной статьи. Но я периодически делюсь подобными техническими тонкостями в коротких постах на &lt;a href=&quot;https://t.me/yet_another_dev&quot;&gt;своём Telegram-канале&lt;/a&gt;. Если вам интересно, буду рад видеть вас среди читателей.&lt;/p&gt;</content><author><name>© 2024 Alexey Fedorov</name><email>your-email@domain.com</email></author><category term="csharp" /><category term="frozendictionary" /><category term="dictionary" /><category term="benchmark" /><category term="hashtable" /><category term="algorithms" /><summary type="html">С релизом .NET 8 в арсенале C# разработчиков появилась новая коллекция – FrozenDictionary. Особенность этого словаря в том, что он неизменяемый, но при этом обеспечивает более быстрое чтение по сравнению с обычным Dictionary. Я неспроста разбил результаты на обложке по типам – используемые во FrozenDictinoary алгоритмы сильно зависят от типа ключа, размера словаря или даже, например, количества строковых ключей одинаковой длины. В этой статье подробно разберем, насколько FrozenDictionary быстрее и почему. English version is here.</summary></entry><entry><title type="html">Ускоряем Dictionary в C# при помощи структур и CollectionsMarshal</title><link href="http://www.alexeyfv.xyz//2024/04/12/collections-marshal.html" rel="alternate" type="text/html" title="Ускоряем Dictionary в C# при помощи структур и CollectionsMarshal" /><published>2024-04-12T00:00:00+00:00</published><updated>2024-04-12T00:00:00+00:00</updated><id>http://www.alexeyfv.xyz//2024/04/12/collections-marshal</id><content type="html" xml:base="http://www.alexeyfv.xyz//2024/04/12/collections-marshal.html">&lt;p&gt;Если вы C# разработчик, то наверняка вам знаком класс Dictionary. В качестве значений вы, скорее всего, использовали классы. Но что если я скажу, что в Dictionary можно использовать структуры? Не стоит бояться того, что структуры копируются при передаче в метод или возврате из него. Есть способ этого избежать, и это работает быстро.&lt;/p&gt;

&lt;h2 id=&quot;дисклеймер&quot;&gt;Дисклеймер&lt;/h2&gt;

&lt;p&gt;Информация в этой статье верна только при определённых условиях. Я допускаю, что бенчмарк может показать другие результаты на другом железе, с другим компилятором, во время другой фазы луны или при другом сценарии использования рассматриваемого функционала языка. Всегда проверяйте ваш код и не полагайтесь лишь на статьи из интернета.&lt;/p&gt;

&lt;h2 id=&quot;сценарий-использования&quot;&gt;Сценарий использования&lt;/h2&gt;

&lt;p&gt;Представим, что есть некоторый массив данных &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt;. От нас требуется реализовать следующий функционал:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Преобразовать &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; в словарь для последующего поиска.&lt;/li&gt;
  &lt;li&gt;По некоторому ключу найти в словаре объект и изменить его.&lt;/li&gt;
  &lt;li&gt;Повторить п. 2 столько раз, сколько требуется.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Напишем код, который имитирует такое поведение:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Инициализация словаря  &lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Заполнение словаря  &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Поиск значения и изменение данных  &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;DoWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Код выше работает как задумано. Давайте попробуем его ускорить. Заменим класс SomeClass на структуру SomeStruct и сравним производительность обоих вариантов.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Инициализация словаря  &lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Заполнение словаря  &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Поиск значения и изменение данных  &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;DoWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;бенчмарк&quot;&gt;Бенчмарк&lt;/h2&gt;

&lt;p&gt;Замер производительности осуществлялся на массиве данных в 100 000 элементов. Размер классов (без заголовка) и структур менялся от 4 до 128 байт. Для замеров производительности я использовал библиотеку &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt;. Код бенчмарка и результаты можно найти в &lt;a href=&quot;https://github.com/alexeyfv/speed-up-the-dictionary&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/04/2024-04-12-collections-marshal/image01.png&quot; alt=&quot;content&quot; /&gt;
&lt;strong&gt;Среднее время выполнения бенчмарка в зависимости от размера сущности&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Результаты бенчмарка показывают ухудшение производительности при использовании структур размером больше 20 байт. В реализации со структурами происходит их многократное копирование, а поиск в словаре осуществляется дважды. Это негативно сказывается на производительности. Давайте разобьем замеры кода на части, чтобы понять, что можно улучшить.&lt;/p&gt;

&lt;h3 id=&quot;инициализация-словаря&quot;&gt;Инициализация словаря&lt;/h3&gt;

&lt;p&gt;Бенчмарк показал ожидаемые результаты. Время инициализации и размер словаря со структурами линейно возрастают с увеличением размера структур.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/04/2024-04-12-collections-marshal/image02.png&quot; alt=&quot;content&quot; /&gt;
&lt;strong&gt;
Среднее время инициализации словаря в зависимости от размера сущности
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Связано это с тем, что массив &lt;a href=&quot;https://github.com/dotnet/runtime/blob/552b5e9b3249e61f87ac5cc73976c55b104971de/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs#L27&quot;&gt;entries&lt;/a&gt; в таком случае хранит непосредственно значения, а не ссылки. Соответственно, для хранения такого словаря нужно банально больше памяти.&lt;/p&gt;

&lt;p&gt;Справедливости ради нужно отметить, что для классов CLR выделила памяти даже больше, просто это произошло ранее – во время инициализации массива &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt;. Если замерять время, затраченное на инициализацию массива классов и структур, то результаты будут не в пользу классов. Но это выходит за рамки статьи.&lt;/p&gt;

&lt;h3 id=&quot;заполнение-словаря&quot;&gt;Заполнение словаря&lt;/h3&gt;

&lt;p&gt;И снова ожидаемые результаты. Время копирования структур, происходящее при заполнении словаря, линейно зависит от размера структур. Хотя разница между структурами и классами практически не заметна вплоть до 20 байт.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/04/2024-04-12-collections-marshal/image03.png&quot; alt=&quot;content&quot; /&gt;
&lt;strong&gt;
Среднее время заполнения словаря в зависимости от размера сущности
&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;поиск-значения-и-его-изменение&quot;&gt;Поиск значения и его изменение&lt;/h3&gt;

&lt;p&gt;И в третий раз результаты не в пользу структур.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/04/2024-04-12-collections-marshal/image04.png&quot; alt=&quot;content&quot; /&gt;
&lt;strong&gt;
Среднее время поиска значения и его изменения в зависимости от размера сущности
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Связано это с тем, что поиск по ключу и копирование структур осуществляется дважды:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;SomeStruct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1-й поиск по ключу и копирование структуры  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;DoWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2-й поиск по ключу и копирование структуры&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вот тут нам и поможет класс &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CollectionsMarshal&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;кто-такой-этот-ваш-collectionsmarshal&quot;&gt;Кто такой этот ваш CollectionsMarshal?&lt;/h2&gt;

&lt;p&gt;Если кратко, то это &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.collectionsmarshal&quot;&gt;класс&lt;/a&gt; с четырьмя extension-методами:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AsSpan&amp;lt;T&amp;gt;&lt;/code&gt; – возвращает &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; для элементов &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetValueRefOrAddDefault&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; – по ключу возвращает из словаря ссылку на элемент &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TValue&lt;/code&gt;, создавая &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt; значение если элемента не существует.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetValueRefOrNullRef&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; – по ключу возвращает из словаря ссылку на элемент &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TValue&lt;/code&gt; или ссылку на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;, если элемента не существует.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SetCount&amp;lt;T&amp;gt;&lt;/code&gt; – устанавливает значение &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Count&lt;/code&gt; для &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Нас интересуют только &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetValueRefOrAddDefault&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetValueRefOrNullRef&lt;/code&gt;. При помощи этих методов можно извлечь значения из словаря по ссылке, что позволит избежать двойного поиска по ключу и двойного копирования структуры. Например, код выше можно переписать следующим образом:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeStruct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CollectionsMarshal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetValueRefOrNullRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;DoWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ещё-немного-бенчмарков&quot;&gt;Ещё немного бенчмарков&lt;/h2&gt;

&lt;p&gt;Сделаем замеры реализации с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetValueRefOrNullRef&lt;/code&gt; и сравним с предыдущими результатами:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/04/2024-04-12-collections-marshal/image05.png&quot; alt=&quot;content&quot; /&gt;
&lt;strong&gt;
Среднее время поиска значения и его изменения в зависимости от размера сущности
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Время выполнения кода с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CollectionsMarshal&lt;/code&gt; даже быстрее, чем с классами. Чтобы компенсировать потери производительности при инициализации и заполнении словаря, количество операций поиска должно быть многократно больше, чем размер массива.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2024/04/2024-04-12-collections-marshal/image06.png&quot; alt=&quot;content&quot; /&gt;
&lt;strong&gt;
Время выполнения бенчмарка. Графики разбиты по количеству операций поиска.
&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;особенности-collectionsmarshal&quot;&gt;Особенности CollectionsMarshal&lt;/h2&gt;

&lt;h3 id=&quot;проверка-на-default-и-null&quot;&gt;Проверка на default и null&lt;/h3&gt;

&lt;p&gt;Как упоминалось ранее, методы GetValueRefOrAddDefault и GetValueRefOrNullRef возвращают ссылку на &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/default#default-literal&quot;&gt;default&lt;/a&gt; структуру и ссылку на null.&lt;/p&gt;

&lt;p&gt;Проверить, дефолтная ли структура, т.е. все поля имеют дефолтное значение, довольно просто – нужно проверить флаг exists:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CollectionsMarshal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetValueRefOrAddDefault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;c1&quot;&gt;// some code here  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Со ссылкой на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt; ситуация другая. Булевого флага нет, а при сравнении с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt; будет выброшено исключение NullReferenceException. Лучше воспользоваться методом &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.unsafe.isnullref?view=net-8.0&quot;&gt;Unsafe.IsNullRef&amp;lt;T&amp;gt;(ref T source)&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CollectionsMarshal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetValueRefOrNullRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unsafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsNullRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;c1&quot;&gt;// some code here  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;изменение-словаря-после-получения-ссылки-на-структуру&quot;&gt;Изменение словаря после получения ссылки на структуру&lt;/h3&gt;

&lt;p&gt;В документации к методам &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetValueRefOrAddDefault&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetValueRefOrNullRef&lt;/code&gt; прямым текстом указано, что нельзя изменять словарь после того, как была получена ссылка на структуру. Почему так делать не надо продемонстрировано на примере ниже. После изменения словаря, любые изменения структуры, полученной по ссылке, не повлияют на значение в словаре.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CollectionsMarshal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetValueRefOrNullRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;$&quot;ref element: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 30  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;$&quot;dict[key]: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 30&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// change #1&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;$&quot;ref element: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 50  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;$&quot;dict[key]: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 50&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// add a new element  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// change #2&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;$&quot;ref element: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 60  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;$&quot;dict[key]: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Item1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 50&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Структуры – недооценённые элементы C#, которые, при определённых условиях, способны ускорить ваше приложение. При использовании структур в качестве значений для &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt; лучше воспользоваться классом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CollectionsMarshal&lt;/code&gt;. Методы этого класса &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetValueRefOrAddDefault&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetValueRefOrNullRef&lt;/code&gt; позволяют получать элементы словаря по ссылке. Это, в свою очередь, может положительно сказаться на производительности кода при относительно большом количестве операций поиска в словаре.&lt;/p&gt;</content><author><name>© 2024 Alexey Fedorov</name><email>your-email@domain.com</email></author><category term="csharp" /><category term="dictionary" /><category term="collectionsmarshal" /><category term="performance" /><category term="benchmark" /><category term="hashtable" /><summary type="html">Если вы C# разработчик, то наверняка вам знаком класс Dictionary. В качестве значений вы, скорее всего, использовали классы. Но что если я скажу, что в Dictionary можно использовать структуры? Не стоит бояться того, что структуры копируются при передаче в метод или возврате из него. Есть способ этого избежать, и это работает быстро.</summary></entry><entry><title type="html">Simplify Integration Testing with Testcontainers</title><link href="http://www.alexeyfv.xyz//2024/02/12/testcontainers.html" rel="alternate" type="text/html" title="Simplify Integration Testing with Testcontainers" /><published>2024-02-12T00:00:00+00:00</published><updated>2024-02-12T00:00:00+00:00</updated><id>http://www.alexeyfv.xyz//2024/02/12/testcontainers</id><content type="html" xml:base="http://www.alexeyfv.xyz//2024/02/12/testcontainers.html">&lt;p&gt;Integration tests play an important role in software development. They help us see how the system works with volatile dependencies, such as databases. To run the integration test with the database, we need somewhere to create this database. It can be deployed on a virtual machine or even on a local host. However, it’s best to use &lt;a href=&quot;https://testcontainers.com/&quot;&gt;Testcontainers framework&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-is-testcontainers&quot;&gt;What is Testcontainers?&lt;/h2&gt;

&lt;p&gt;Testcontainers is a library that provides easy and lightweight APIs for bootstrapping local development and test dependencies with real services wrapped in Docker containers. Using Testcontainers, you can write tests that depend on the same services you use in production without mocks or in-memory services (stolen from this &lt;a href=&quot;https://testcontainers.com/getting-started/&quot;&gt;page&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;usage-example&quot;&gt;Usage example&lt;/h2&gt;

&lt;p&gt;Consider the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UserInfoService&lt;/code&gt; class below. Basically, the service tries to get &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UserInfo&lt;/code&gt; from the memory cache. If this fails, the service tries to extract the data from the database. If this also fails, the service returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;record&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UserInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserInfoService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConcurrentDictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UserInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UserInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// The fastest way - get userinfo from memory cache&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;TryGetValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Slower way - get userinfo from database&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;TryAdd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now let’s consider the following scenario. If the key doesn’t exist in the cache, the service calls a database. Knowing that information, we can implement the integration tests with Testcontainers. But before that, we also need implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IRepository&lt;/code&gt; and migrations.&lt;/p&gt;

&lt;h3 id=&quot;repository-implementation&quot;&gt;Repository implementation&lt;/h3&gt;

&lt;p&gt;We’re going to use PostgreSQL, so let’s add it to the project.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dotnet add package Npgsql &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt; 8.0.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I also prefer to use Dapper to avoid &lt;a href=&quot;https://www.learndapper.com/#what-does-dapper-do&quot;&gt;the boilerplate code with SqlCommand&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dotnet add package Dapper &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt; 2.1.28
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The implementation of the repository is pretty simple.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IRepository&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UserInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UserInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_connectionString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IRepository&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NpgsqlConnection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_connectionString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_selectQuery&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;SELECT &quot;&quot;Id&quot;&quot;, &quot;&quot;Name&quot;&quot;, &quot;&quot;Address&quot;&quot; FROM &quot;&quot;Users&quot;&quot; WHERE &quot;&quot;Id&quot;&quot; = @Id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_insertQuery&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;INSERT INTO &quot;&quot;Users&quot;&quot; (&quot;&quot;Id&quot;&quot;, &quot;&quot;Name&quot;&quot;, &quot;&quot;Address&quot;&quot;) VALUES (@Id, @Name, @Address)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UserInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ExecuteAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_insertQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UserInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QueryFirstOrDefaultAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UserInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_selectQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Id&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;database-migrations&quot;&gt;Database migrations&lt;/h3&gt;

&lt;p&gt;For migrations, we’re going to use &lt;a href=&quot;https://github.com/fluentmigrator/fluentmigrator&quot;&gt;FluentMigrator&lt;/a&gt; library.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dotnet add package FluentMigrator &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt; 5.0.0
dotnet add package FluentMigrator.Runner.Postgres &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt; 5.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The initial migration creates a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Users&lt;/code&gt; table.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Migration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;20240212&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Creates Users table&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InitialMigration&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Migration&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Up&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Users&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WithColumn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AsString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PrimaryKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WithColumn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AsString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WithColumn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AsString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Down&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Users&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To run the migration, we need to execute &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MigrateUp&lt;/code&gt; method.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Migrator&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MigrateUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectionString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceProvider&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ServiceCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Add common FluentMigrator services&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddFluentMigratorCore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ConfigureRunner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rb&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Add SQLite support to FluentMigrator&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddPostgres&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Set the connection string&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WithGlobalConnectionString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connectionString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Define the assembly containing the migrations&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ScanIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InitialMigration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Assembly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;For&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Migrations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Enable logging to console in the FluentMigrator way&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddLogging&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddFluentMigratorConsole&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Build the service provider&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;BuildServiceProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;migrationRunner&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetRequiredService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IMigrationRunner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;migrationRunner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;MigrateUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;integration-tests&quot;&gt;Integration tests&lt;/h3&gt;

&lt;p&gt;Now, we’re ready to write integration tests. Let’s create a new MSTest project.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dotnet new mstest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We use PostgreSQL, so it’s necessary to install the Testcontainers.PostgreSql nuget package.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dotnet add package Testcontainers.PostgreSql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is the integration test code:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IntegrationTests&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Build a Docker image of PostgreSQL instance&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PostgreSqlContainer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_postgres&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PostgreSqlBuilder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WithImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;postgres:16-alpine&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Build&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Run the container before testing&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassInitialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_postgres&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;StartAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Stop the container when all the tests within this class have completed&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassCleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Cleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_postgres&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;DisposeAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AsTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TestMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Arrange&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectionString&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_postgres&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetConnectionString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Migrator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;MigrateUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connectionString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connectionString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UserInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;John Doe&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Some address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sut&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UserInfoService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Act&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Assert&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;IsNotNull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AreEqual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AreEqual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AreEqual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That’s it. As we can see, the basic usage of Testcontainers is very easy.&lt;/p&gt;</content><author><name>© 2024 Alexey Fedorov</name><email>your-email@domain.com</email></author><category term="csharp" /><category term="testing" /><summary type="html">Integration tests play an important role in software development. They help us see how the system works with volatile dependencies, such as databases. To run the integration test with the database, we need somewhere to create this database. It can be deployed on a virtual machine or even on a local host. However, it’s best to use Testcontainers framework.</summary></entry></feed>