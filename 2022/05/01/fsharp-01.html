<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" sizes="16x16 32x32 48x48" href="/assets/favicon/favicon.ico">
    <link rel="apple-touch-icon" href="/assets/favicon/apple-touch-icon.png"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Функциональное программирование на F# (часть 1) | alexeyfv</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Функциональное программирование на F# (часть 1)" />
<meta name="author" content="© 2024 Alexey Fedorov" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Недавно прочитал книгу 1 “Unit Testing Principles, Practices, and Patterns” Владимира Хорикова. Книга классная, фундаментальная. В плане полезности для .NET backend разработчиков, по-моему, стоит на уровне CLR via C#, Dependency Injection in .NET, Patterns of Enterprise Application Architecture и т.д. Помимо вопросов тестирования, она также вкратце объясняет вопросы функциональной архитектуры и то, как такая архитектура положительно влияет на возможность тестирования кода. Ранее мне не приходилось сталкиваться с функциональными языками программирования, но после прочтения книги очень захотелось поработать с ними. Поскольку я C# разработчик, то проще всего было начать изучать функциональное программирование с другой разработкой Microsoft - языка F#. В этой статье мы попробуем реализовать один и тот же алгоритм в функциональном стиле на C# и F# и сравнить результат. “Unit Testing Principles, Practices, and Patterns” &#8617;" />
<meta property="og:description" content="Недавно прочитал книгу 1 “Unit Testing Principles, Practices, and Patterns” Владимира Хорикова. Книга классная, фундаментальная. В плане полезности для .NET backend разработчиков, по-моему, стоит на уровне CLR via C#, Dependency Injection in .NET, Patterns of Enterprise Application Architecture и т.д. Помимо вопросов тестирования, она также вкратце объясняет вопросы функциональной архитектуры и то, как такая архитектура положительно влияет на возможность тестирования кода. Ранее мне не приходилось сталкиваться с функциональными языками программирования, но после прочтения книги очень захотелось поработать с ними. Поскольку я C# разработчик, то проще всего было начать изучать функциональное программирование с другой разработкой Microsoft - языка F#. В этой статье мы попробуем реализовать один и тот же алгоритм в функциональном стиле на C# и F# и сравнить результат. “Unit Testing Principles, Practices, and Patterns” &#8617;" />
<link rel="canonical" href="http://www.alexeyfv.xyz//2022/05/01/fsharp-01.html" />
<meta property="og:url" content="http://www.alexeyfv.xyz//2022/05/01/fsharp-01.html" />
<meta property="og:site_name" content="alexeyfv" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-01T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Функциональное программирование на F# (часть 1)" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"© 2024 Alexey Fedorov"},"description":"Недавно прочитал книгу 1 “Unit Testing Principles, Practices, and Patterns” Владимира Хорикова. Книга классная, фундаментальная. В плане полезности для .NET backend разработчиков, по-моему, стоит на уровне CLR via C#, Dependency Injection in .NET, Patterns of Enterprise Application Architecture и т.д. Помимо вопросов тестирования, она также вкратце объясняет вопросы функциональной архитектуры и то, как такая архитектура положительно влияет на возможность тестирования кода. Ранее мне не приходилось сталкиваться с функциональными языками программирования, но после прочтения книги очень захотелось поработать с ними. Поскольку я C# разработчик, то проще всего было начать изучать функциональное программирование с другой разработкой Microsoft - языка F#. В этой статье мы попробуем реализовать один и тот же алгоритм в функциональном стиле на C# и F# и сравнить результат. “Unit Testing Principles, Practices, and Patterns” &#8617;","@type":"BlogPosting","headline":"Функциональное программирование на F# (часть 1)","dateModified":"2022-05-01T00:00:00+00:00","datePublished":"2022-05-01T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.alexeyfv.xyz//2022/05/01/fsharp-01.html"},"url":"http://www.alexeyfv.xyz//2022/05/01/fsharp-01.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://www.alexeyfv.xyz//feed.xml" title="alexeyfv" />
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">alexeyfv</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/tags/">Tags</a><a class="page-link" href="/cv/">CV</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article
  class="post h-entry"
  itemscope
  itemtype="http://schema.org/BlogPosting"
>
  <link rel="stylesheet" href="/static/glide/css/glide.core.min.css" />
  <link rel="stylesheet" href="/static/glide/css/glide.theme.min.css" />
  <script type="text/javascript" src="/static/glide/glide.min.js"></script>
  <link href="/static/syntax-highlighting.css" rel="stylesheet" />
  <link href="/static/image.css" rel="stylesheet" />
  <script>
    function initGlideCarousel() {
      var sliders = document.querySelectorAll(".glide");
      const conf = {};
      sliders.forEach((item) => {
        new Glide(item, conf).mount();
      });
    }
    document.addEventListener("DOMContentLoaded", initGlideCarousel);
  </script>
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">
      Функциональное программирование на F# (часть 1)
    </h1>
    <p class="post-meta"><time
        class="dt-published"
        datetime="2022-05-01T00:00:00+00:00"
        itemprop="datePublished"
      >
        May 1, 2022
      </time></p>
    
    <a class="post" href="/tag/dotnet">#dotnet</a>
    
    <a class="post" href="/tag/fsharp">#fsharp</a>
    
    <a class="post" href="/tag/csharp">#csharp</a>
    
    <a class="post" href="/tag/functional_programming">#functional_programming</a>
    
  </header>

  <div class="post-content e-content" itemprop="articleBody"><p>Недавно прочитал книгу <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> “Unit Testing Principles, Practices, and Patterns” Владимира Хорикова. Книга классная, фундаментальная. В плане полезности для .NET backend разработчиков, по-моему, стоит на уровне CLR via C#, Dependency Injection in .NET, Patterns of Enterprise Application Architecture и т.д. Помимо вопросов тестирования, она также вкратце объясняет вопросы функциональной архитектуры и то, как такая архитектура положительно влияет на возможность тестирования кода. Ранее мне не приходилось сталкиваться с функциональными языками программирования, но после прочтения книги очень захотелось поработать с ними. Поскольку я C# разработчик, то проще всего было начать изучать функциональное программирование с другой разработкой Microsoft - языка F#. В этой статье мы попробуем реализовать один и тот же алгоритм в функциональном стиле на C# и F# и сравнить результат.</p>

<h2 id="объектно-ориентированное-программирование">Объектно-ориентированное программирование</h2>

<p>Предположим, нам нужно реализовать функционал, который будет вычислять <code class="language-plaintext highlighter-rouge">n</code> первых чисел ряда Фибоначчи и выводить значения в консоль. Такую задачу на C# можно было бы решить вот так <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">FibonacciWriter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Write</span><span class="p">(</span><span class="kt">uint</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">prev</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">next</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>

        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

        <span class="kt">uint</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>

        <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="p">++</span> <span class="p">&lt;</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">next2</span> <span class="p">=</span> <span class="n">prev</span> <span class="p">+</span> <span class="n">next</span><span class="p">;</span>
            <span class="n">prev</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="n">next</span> <span class="p">=</span> <span class="n">next2</span><span class="p">;</span>

            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Какие проблемы могут возникнуть у такой реализации? Например, если потребуется изменить вывод консоль на вывод в файл, то мы не можем этого сделать. Это явное нарушение принципа Open/Closed. Чтобы избежать таких проблем, можно добавить абстрактный метод <code class="language-plaintext highlighter-rouge">Output</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">FibonacciWriter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Write</span><span class="p">(</span><span class="kt">uint</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">prev</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">next</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>

        <span class="nf">Output</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

        <span class="kt">uint</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>

        <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="p">++</span> <span class="p">&lt;</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">next2</span> <span class="p">=</span> <span class="n">prev</span> <span class="p">+</span> <span class="n">next</span><span class="p">;</span>
            <span class="n">prev</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="n">next</span> <span class="p">=</span> <span class="n">next2</span><span class="p">;</span>

            <span class="nf">Output</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">abstract</span> <span class="k">void</span> <span class="nf">Output</span><span class="p">(</span><span class="kt">uint</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">FibonacciConsoleWriter</span> <span class="p">:</span> <span class="n">FibonacciWriter</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Output</span><span class="p">(</span><span class="kt">uint</span> <span class="n">i</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="s"> "</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>В целом, такая реализация более менее нормальная и часто встречается на практике, но она нарушает принцип Single Responsibility. К тому же, для такого класса трудно написать unit-тест, т.к. метод <code class="language-plaintext highlighter-rouge">Write</code> ничего не возвращает и для проверки результата придётся переопределять метод <code class="language-plaintext highlighter-rouge">Output</code>. Очевидно, что для решения этой проблемы нам нужно разделить расчёт ряда Фибоначчи и вывод значений. Для этого к нам на помощь придёт функциональный подход.</p>

<h2 id="функциональное-программирование">Функциональное программирование</h2>

<p>Функциональное программирование основано на использовании чистых функций. Согласно <a href="https://en.wikipedia.org/wiki/Pure_function">Википедии</a>, чистая функция - это функция, которая:</p>

<ol>
  <li>Возвращает один и тот же результат для одних и тех же аргументов.</li>
  <li>Не имеет побочных эффектов (не выполняет изменение объектов, изменение файлов и т.д.)</li>
</ol>

<p>Вернёмся к классу <code class="language-plaintext highlighter-rouge">FibonacciWriter</code>. Является ли метод <code class="language-plaintext highlighter-rouge">Write</code> - чистой функцией? Конечно же нет. Во-первых, мы не можем сопоставить результат выполнения метода с входными аргументами (метод вообще ничего не возвращает). Во-вторых, метод имеет побочные эффекты в виде изменения переменных и вывода в консоль.</p>

<p>Давайте перепишем класс <code class="language-plaintext highlighter-rouge">FibonacciWriter</code> в функциональном стиле:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Fibonacci</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">uint</span><span class="p">&gt;</span> <span class="nf">Get</span><span class="p">(</span><span class="kt">uint</span> <span class="n">n</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nf">Next</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">).</span><span class="nf">Take</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>

    <span class="k">private</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">uint</span><span class="p">&gt;</span> <span class="nf">Next</span><span class="p">(</span><span class="kt">uint</span> <span class="n">previous</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">current</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">previous</span><span class="p">;</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="nf">Next</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">previous</span> <span class="p">+</span> <span class="n">current</span><span class="p">))</span> 
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">item</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Основные отличия функциональной реализации:</p>

<ul>
  <li>Метод <code class="language-plaintext highlighter-rouge">Get</code> возвращает коллекцию типа <code class="language-plaintext highlighter-rouge">IEnumerable&lt;uint&gt;</code>. Это значительно упрощает тестирование.</li>
  <li>Данные в классе иммутабельны. Если нет изменяющихся данных, то не требуется синхронизация потоков (для данного примера не актуально, но всё же).</li>
  <li>Нет side-эффектов. При написании тестов не понадобится создавать mock-объект и проверять вызов метода <code class="language-plaintext highlighter-rouge">Output</code>.</li>
  <li>Появляется возможность независимо друг от друга развивать класс <code class="language-plaintext highlighter-rouge">Fibonacci</code> и класс, отвечающий за вывод данных.</li>
</ul>

<p>Получается, что на C# тоже можно писать в функциональном стиле. Зачем тогда использовать F#? Я вижу несколько причин:</p>

<ul>
  <li>Данные в F# иммутабельны по-умолчанию. Язык не позволяет просто так поменять значение переменной (строго говоря, это и не переменные вовсе). Такой подход заставляет разработчика писать не так, как в классических ООП языках.</li>
  <li>Синтаксис F# больше заточен под функциональное программирование (спасибо, кэп).</li>
</ul>

<p>Перепишем класс <code class="language-plaintext highlighter-rouge">Fibonacci</code> на F#:</p>

<div class="language-fsharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">Fibonacci</span> <span class="p">=</span>

    <span class="k">let</span> <span class="n">next</span> <span class="p">(</span><span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span> <span class="p">=</span> 
        <span class="nc">Some</span><span class="p">(</span><span class="n">previous</span><span class="p">,</span> <span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">previous</span> <span class="o">+</span> <span class="n">current</span><span class="o">))</span>

    <span class="k">let</span> <span class="n">get</span> <span class="n">n</span> <span class="p">=</span> <span class="nn">Seq</span><span class="p">.</span><span class="n">unfold</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">|&gt;</span> <span class="nn">Seq</span><span class="p">.</span><span class="n">take</span> <span class="n">n</span>
</code></pre></div></div>

<p>Как мы видим, код довольно сильно отличается от C#. Что тут изменилось:</p>

<ul>
  <li>Написано меньше кода, нет фигурных скобок. Для разделения блоков кода используются отступы, как на Python.</li>
  <li>Для генерации значений ряда Фибоначчи используется <code class="language-plaintext highlighter-rouge">Seq.unfold</code>. По-сути, эта конструкция является эквивалентом ключевого слова <code class="language-plaintext highlighter-rouge">yield</code> в C#. При помощи <code class="language-plaintext highlighter-rouge">Seq.unfold</code> можно создавать коллекции с неизвестным конечным размером.</li>
  <li>Оператор <code class="language-plaintext highlighter-rouge">|&gt;</code> или pipe-оператор. Предназначен для создания цепочки вызовов.</li>
  <li>Нет объявлений типов. F# очень хорошо умеет выводить типы значений и функций.</li>
</ul>

<h2 id="c--f">C# + F#</h2>

<p>Прелесть всех языков .NET в том, что код написанный на F#, можно вызывать в программе на C#. Поэтому, можно спокойно написать вот такой код:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">"F# Fibonacci: "</span><span class="p">);</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">FSharp</span><span class="p">.</span><span class="n">Fibonacci</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="m">10</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">item</span><span class="p">}</span><span class="s"> "</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">();</span>
</code></pre></div></div>

<p>На C#, кстати, модуль <code class="language-plaintext highlighter-rouge">Fibonacci</code> будет в виде статического класса, а функции <code class="language-plaintext highlighter-rouge">get</code> и <code class="language-plaintext highlighter-rouge">next</code> станут статическими (что там происходит под капотом разберём в следующей статье):</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Fibonacci</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">FSharpOption</span><span class="p">&lt;</span><span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;&gt;&gt;</span> <span class="nf">next</span><span class="p">(</span><span class="kt">int</span> <span class="n">previous</span><span class="p">,</span> <span class="kt">int</span> <span class="n">current</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// next implementation</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="k">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// get implementation</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Такой подход (использование C# в связке с F#), на мой взгляд, позволяет в приложениях эффективно разделить Business Logic Layer от Data Access Layer или Service Layer. На F# можно написать функциональное ядро для Business Logic, а всё остальное - на C#.</p>

<h2 id="резюме">Резюме</h2>

<p>Использование функционального подхода в программировании позволяет писать чистую архитектуру приложения, которая отвечает принципам SOLID. Для таких приложений проще писать тесты и их проще сопровождать. Поскольку для F# функциональное программирование является основной парадигмой, то писать в функциональный код на нём намного проще.</p>

<h2 id="ссылки">Ссылки</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://www.manning.com/books/unit-testing">“Unit Testing Principles, Practices, and Patterns”</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://github.com/alexeyfv/FunctionalProgramming">“Исходный код”</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div><a class="u-url" href="/2022/05/01/fsharp-01.html" hidden></a>
</article>

<script
  src="https://utteranc.es/client.js"
  repo="alexeyfv/blog"
  issue-term="url"
  label="comment"
  theme="github-dark"
  crossorigin="anonymous"
  async
></script>

      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/"></data>
  
    <div class="wrapper">
  
      <div class="footer-col-wrapper">
        <div class="footer-col">
          <ul class="contact-list">
            <li class="p-name">© 2024 Alexey Fedorov</li>
              <li class="p-name">Powered by
                <a href="https://github.com/jekyll/jekyll">Jekyll</a> 
                &
                <a href="https://github.com/jekyll/minima">Minima</a>
              </li>
            </ul>
        </div>
        <div class="footer-col">
          <p>Articles about .NET, C# and much more</p>
        </div>
      </div>
  
      <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://www.linkedin.com/in/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li><li><a rel="me" href="https://t.me/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#telegram"></use></svg></a></li></ul></div>
  
    </div>
  
  </footer></body>

</html>
