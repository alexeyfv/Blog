<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" sizes="16x16 32x32 48x48" href="/assets/favicon/favicon.ico">
    <link rel="apple-touch-icon" href="/assets/favicon/apple-touch-icon.png"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>FrozenDictionary under the hood: how fast is it comparing to Dictionary and why | alexeyfv</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="FrozenDictionary under the hood: how fast is it comparing to Dictionary and why" />
<meta name="author" content="© 2024 Alexey Fedorov" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="With .NET 8 release, C# developers received a new type of generic collections – FrozenDictionary. The main feature of this dictionary is that it’s immutable, but allows reading the data faster comparing to a plain Dictionary. I split the results on the cover by a reason: the algorithms used in FrozenDictionary are highly depended on key type, the size of the array or even the number of the string keys with the same length. In this article, we’ll look into details how fast is FrozenDictionary and why. Version in Russian is here Версия на русском тут." />
<meta property="og:description" content="With .NET 8 release, C# developers received a new type of generic collections – FrozenDictionary. The main feature of this dictionary is that it’s immutable, but allows reading the data faster comparing to a plain Dictionary. I split the results on the cover by a reason: the algorithms used in FrozenDictionary are highly depended on key type, the size of the array or even the number of the string keys with the same length. In this article, we’ll look into details how fast is FrozenDictionary and why. Version in Russian is here Версия на русском тут." />
<link rel="canonical" href="http://www.alexeyfv.xyz//2024/10/09/frozen-dictionary.html" />
<meta property="og:url" content="http://www.alexeyfv.xyz//2024/10/09/frozen-dictionary.html" />
<meta property="og:site_name" content="alexeyfv" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-10-09T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="FrozenDictionary under the hood: how fast is it comparing to Dictionary and why" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"© 2024 Alexey Fedorov"},"description":"With .NET 8 release, C# developers received a new type of generic collections – FrozenDictionary. The main feature of this dictionary is that it’s immutable, but allows reading the data faster comparing to a plain Dictionary. I split the results on the cover by a reason: the algorithms used in FrozenDictionary are highly depended on key type, the size of the array or even the number of the string keys with the same length. In this article, we’ll look into details how fast is FrozenDictionary and why. Version in Russian is here Версия на русском тут.","@type":"BlogPosting","headline":"FrozenDictionary under the hood: how fast is it comparing to Dictionary and why","dateModified":"2024-10-09T00:00:00+00:00","datePublished":"2024-10-09T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.alexeyfv.xyz//2024/10/09/frozen-dictionary.html"},"url":"http://www.alexeyfv.xyz//2024/10/09/frozen-dictionary.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://www.alexeyfv.xyz//feed.xml" title="alexeyfv" />
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">alexeyfv</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/tags/">Tags</a><a class="page-link" href="/cv/">CV</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article
  class="post h-entry"
  itemscope
  itemtype="http://schema.org/BlogPosting"
>
  <link rel="stylesheet" href="/static/glide/css/glide.core.min.css" />
  <link rel="stylesheet" href="/static/glide/css/glide.theme.min.css" />
  <script type="text/javascript" src="/static/glide/glide.min.js"></script>
  <link href="/static/syntax-highlighting.css" rel="stylesheet" />
  <link href="/static/image.css" rel="stylesheet" />
  <script>
    function initGlideCarousel() {
      var sliders = document.querySelectorAll(".glide");
      const conf = {};
      sliders.forEach((item) => {
        new Glide(item, conf).mount();
      });
    }
    document.addEventListener("DOMContentLoaded", initGlideCarousel);
  </script>
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">
      FrozenDictionary under the hood: how fast is it comparing to Dictionary and why
    </h1>
    <p class="post-meta"><time
        class="dt-published"
        datetime="2024-10-09T00:00:00+00:00"
        itemprop="datePublished"
      >
        Oct 9, 2024
      </time></p>
    
    <a class="post" href="/tag/csharp">#csharp</a>
    
    <a class="post" href="/tag/frozendictionary">#frozendictionary</a>
    
    <a class="post" href="/tag/dictionary">#dictionary</a>
    
    <a class="post" href="/tag/performance">#performance</a>
    
    <a class="post" href="/tag/benchmark">#benchmark</a>
    
    <a class="post" href="/tag/hashtable">#hashtable</a>
    
    <a class="post" href="/tag/algorithms">#algorithms</a>
    
  </header>

  <div class="post-content e-content" itemprop="articleBody"><p>With <a href="https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8/runtime#performance-focused-types">.NET 8 release</a>, C# developers received a new type of generic collections – <code class="language-plaintext highlighter-rouge">FrozenDictionary</code>. The main feature of this dictionary is that it’s immutable, but allows reading the data faster comparing to a plain <code class="language-plaintext highlighter-rouge">Dictionary</code>. I split the results on the cover by a reason: the algorithms used in <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> are highly depended on key type, the size of the array or even the number of the string keys with the same length. In this article, we’ll look into details how fast is <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> and why.</p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image01.png" alt="FrozenDictionary performance comparing to Dictionary" /></p>

<p><em>Version in Russian is <a href="/2024/08/22/frozen-dictionary.html">here</a></em></p>

<p><em>Версия на русском <a href="/2024/08/22/frozen-dictionary.html">тут</a></em>.</p>

<!--more-->

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#table-of-contents">Table of Contents</a></li>
  <li><a href="#before-we-get-started">Before we get started</a></li>
  <li><a href="#disclaimer">Disclaimer</a></li>
  <li><a href="#group-1-default-dictionaries">Group 1. Default dictionaries</a>
    <ul>
      <li><a href="#search-algorithm">Search algorithm</a></li>
      <li><a href="#benchmark">Benchmark</a></li>
    </ul>
  </li>
  <li><a href="#group-2-dictionary-for-int32-keys">Group 2. Dictionary for Int32 keys</a>
    <ul>
      <li><a href="#search-algorithm-1">Search algorithm</a></li>
      <li><a href="#benchmark-1">Benchmark</a></li>
    </ul>
  </li>
  <li><a href="#group-3-dictionary-with-bucket-sort-algorithm">Group 3. Dictionary with bucket sort algorithm</a>
    <ul>
      <li><a href="#search-algorithm-2">Search algorithm</a></li>
      <li><a href="#benchmark-2">Benchmark</a></li>
    </ul>
  </li>
  <li><a href="#group-4-dictionary-with-string-keys">Group 4. Dictionary with string keys</a>
    <ul>
      <li><a href="#search-algorithm-3">Search algorithm</a></li>
      <li><a href="#benchmark-3">Benchmark</a></li>
    </ul>
  </li>
  <li><a href="#group-5-small-dictionaries">Group 5. Small dictionaries</a>
    <ul>
      <li><a href="#search-algorithm-4">Search algorithm</a></li>
      <li><a href="#benchmark-4">Benchmark</a></li>
    </ul>
  </li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="before-we-get-started">Before we get started</h2>

<p>It’s important to notice, that <code class="language-plaintext highlighter-rouge">FrozenDictionary&lt;TKey, TValue&gt;</code> is an abstract class with <a href="https://github.com/dotnet/runtime/tree/51e99e12a8a09c69e30fdcb004facf68f73173a6/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen">multiple derived classes</a>. To be precise, there are 18 classes. Instead of explaining which implementation is used when, just look at the diagram in Figure 1.</p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image02.png" alt="Choosing a FrozenDictionary implementation" />
<strong>
Figure 1 – Choosing a FrozenDictionary implementation
</strong></p>

<p>Don’t be afraid, because all these 18 implementations can be combined into 5 groups:</p>

<ol>
  <li>In <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/DefaultFrozenDictionary.cs">DefaultFrozenDictionary</a> and <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/ValueTypeDefaultComparerFrozenDictionary.cs">ValueTypeDefaultComparerFrozenDictionary</a> a <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs">FrozenHashTable</a> is used.</li>
  <li>In Int32FrozenDictionary the FrozenHashTable is also used, but there is no hash code calculation, because the key is hash code itself.</li>
  <li><a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/LengthBucketsFrozenDictionary.cs">LengthBucketsFrozenDictionary</a> uses an algorithm which is similar to a <a href="https://en.wikipedia.org/wiki/Bucket_sort">bucket sort</a>.</li>
  <li>All 11 <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs">OrdinalStringFrozenDictionary</a> implementations are also use FrozenHashTable, but they have a specific hash code calculation algorithm.</li>
  <li><a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallValueTypeComparableFrozenDictionary.cs#L18">SmallValueTypeComparableFrozenDictionary</a>, <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallValueTypeDefaultComparerFrozenDictionary.cs#L12">SmallValueTypeDefaultComparerFrozenDictionary</a> and <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallFrozenDictionary.cs#L18">SmallFrozenDictionary</a> use linear search, because their size is not greater than 10 elements.</li>
</ol>

<p>The choosing of the appropriate implementation depends on the multiple parameters and done in <a href="https://github.com/dotnet/runtime/blob/51e99e12a8a09c69e30fdcb004facf68f73173a6/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenDictionary.cs#L113">CreateFromDictionary method of a FrozenDictionary static class</a>. Now, let’s take a look at each group separately and their algorithms, and run benchmarks.</p>

<h2 id="disclaimer">Disclaimer</h2>

<p>The results of the benchmarks are very conditional. I admit, that the benchmark may show different results on a different computer, with a different CPU, with a different compiler or in a different scenario. Always check your code in your specific conditions and don’t trust to the articles from the internet.</p>

<p>The source code and raw results are located in <a href="https://github.com/alexeyfv/frozen-dictionary">this repo</a>.</p>

<h2 id="group-1-default-dictionaries">Group 1. Default dictionaries</h2>

<p>As I said earlier, the <code class="language-plaintext highlighter-rouge">FrozehHashTable</code> structure is used in <code class="language-plaintext highlighter-rouge">DefaultFrozenDictionary</code> and <code class="language-plaintext highlighter-rouge">ValueTypeDefaultComparerFrozenDictionary</code>. This structure, as you may guess from its name, is a hash table implementation. For better understanding how <code class="language-plaintext highlighter-rouge">FrozenHashTable</code> differs from <code class="language-plaintext highlighter-rouge">Dictionary</code>, need to remember how search is implemented in <code class="language-plaintext highlighter-rouge">Dictionary</code>. If you already know this part, you may skip the following explanation.</p>

<p>Let’s consider the following dictionary:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">dictionary</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Fruit</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;()</span>  
<span class="p">{</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"apple"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"APPLE"</span><span class="p">,</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"grape"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"GRAPE"</span><span class="p">,</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"lemon"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"LEMON"</span><span class="p">,</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"fig"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"FIG"</span><span class="p">,</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"lime"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"LIME"</span><span class="p">,</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"kiwi"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"KIWI"</span><span class="p">,</span>  
<span class="p">};</span>

<span class="k">public</span> <span class="n">record</span> <span class="nf">Fruit</span><span class="p">(</span><span class="kt">string</span> <span class="n">Value</span><span class="p">);</span>
</code></pre></div></div>

<p>When, for example, we search a value for <code class="language-plaintext highlighter-rouge">Fruit("fig")</code> key, the following are happened in <code class="language-plaintext highlighter-rouge">Dictionary</code> (Figure 2):</p>

<ol>
  <li>Calculate the key <code class="language-plaintext highlighter-rouge">hashcode</code>.</li>
  <li>Calculate the index of the bucket (<code class="language-plaintext highlighter-rouge">bucketIndex</code>).</li>
  <li>If the key in the entry is equal to the searchable key, then we return the related value. Otherwise, we go to the next entry and repeat step 3.</li>
</ol>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image03.png" alt="Search in Dictionary" />
<strong>
Figure 2 – Search in Dictionary
</strong></p>

<h3 id="search-algorithm">Search algorithm</h3>

<p><code class="language-plaintext highlighter-rouge">FrozenDictionary</code> immutability allows working with buckets differently. Since the number of key-value pairs don’t change, it’s possible to:</p>

<ol>
  <li><a href="https://github.com/dotnet/runtime/blob/c788546f9ad43ea17981d5dc9343b00b6f76d98f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs#L47">Select the number of buckets</a> so that the number of collisions will be <a href="https://github.com/dotnet/runtime/blob/3eba70227be23baee21c13a7ab9316d58d469b82/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs#L151">no more than 5%</a>.</li>
  <li>Place keys and values in the <code class="language-plaintext highlighter-rouge">_keys</code> and <code class="language-plaintext highlighter-rouge">_values</code> ​​arrays, instead of a linked list in the <code class="language-plaintext highlighter-rouge">Dictionary</code>. This makes search more efficient due to higher data locality.</li>
</ol>

<p>Using <code class="language-plaintext highlighter-rouge">FrozenDictionary</code>, searching for a value for the key <code class="language-plaintext highlighter-rouge">Fruit("fig")</code> would look like this (Figure 3):</p>

<ol>
  <li>Calculate the <code class="language-plaintext highlighter-rouge">hashCode</code> of the key.</li>
  <li>Calculate the <code class="language-plaintext highlighter-rouge">bucketIndex</code>.</li>
  <li>In a <code class="language-plaintext highlighter-rouge">bucket</code> array, receive values <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">end</code>. These values are boundaries in a <code class="language-plaintext highlighter-rouge">HashCodes</code> array.</li>
  <li>Iterate the <code class="language-plaintext highlighter-rouge">HashCodes</code> array from <code class="language-plaintext highlighter-rouge">start</code> to <code class="language-plaintext highlighter-rouge">end</code> and search the key. If found, return the value. Otherwise, return null.</li>
</ol>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image04.png" alt="Search in DefaultFrozenDictionary" />
<strong>
Figure 3 – Search in DefaultFrozenDictionary
</strong></p>

<h3 id="benchmark">Benchmark</h3>

<p>The benchmarks results for <code class="language-plaintext highlighter-rouge">DefaultFrozenDictionary</code> and <code class="language-plaintext highlighter-rouge">ValueTypeDefaultComparerFrozenDictionary</code> are on Figure 4 and 5.</p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image05.png" alt="Reading speed from ValueTypeDefaultComparerFrozenDictionary comparing to Dictionary" />
<strong>
Reading speed from ValueTypeDefaultComparerFrozenDictionary comparing to Dictionary
</strong></p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image06.png" alt="Reading speed from DefaultFrozenDictionary comparing to Dictionary" />
<strong>
Reading speed from DefaultFrozenDictionary comparing to Dictionary
</strong></p>

<p>The high search speed in <code class="language-plaintext highlighter-rouge">Dictionary</code> compared to <code class="language-plaintext highlighter-rouge">ValueTypeDefaultComparerFrozenDictionary</code> for dictionaries with up to 1000 elements is probably due to aggressive <a href="https://en.wikipedia.org/wiki/Inline_function">method inlining</a> in Dictionary. I couldn’t understand why the limit is exactly 1000 elements, as there’s nothing about this in the <a href="https://github.com/dotnet/runtime/blob/10107d3ca202bf1fda76a1bf575d782be4be27c3/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs">source code</a>. It might be related to the JIT compiler’s implementation. If you have any ideas on this, feel free to share them in the comments.</p>

<p>In other cases, <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> is 31-32% faster for value types and 17-18% faster for reference types.</p>

<h2 id="group-2-dictionary-for-int32-keys">Group 2. Dictionary for Int32 keys</h2>

<p><code class="language-plaintext highlighter-rouge">Int32FrozenDictionary</code> also uses <code class="language-plaintext highlighter-rouge">FrozenHashTable</code>. The main feature of this class is that if the key type is an integer, its hash is equal to its value, so collisions in such a dictionary are impossible. For example, you can’t add two elements with the key 123 – an exception will be thrown.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">dict</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;();</span>  
<span class="n">dict</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">123</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>  
<span class="n">dict</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">123</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span> <span class="c1">// System.ArgumentException: An item with the same key has already been added.</span>
</code></pre></div></div>

<h3 id="search-algorithm-1">Search algorithm</h3>

<p>This allows skipping the hash calculation during reads and <a href="https://github.com/dotnet/runtime/blob/eb455ec34c6709e487c19e52c29ec712a6fa4d7f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/Int32/Int32FrozenDictionary.cs#L35">using the key’s value directly</a>. As a result, value lookup works like this (Figure 6):</p>

<ol>
  <li>The bucket index is calculated directly from the key’s value.</li>
  <li>From the <code class="language-plaintext highlighter-rouge">bucket</code> array, we get the <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">end</code> values, which define the boundaries in the HashCodes array.</li>
  <li>We iterate through the <code class="language-plaintext highlighter-rouge">HashCodes</code> array from <code class="language-plaintext highlighter-rouge">start</code> to <code class="language-plaintext highlighter-rouge">end</code>, looking for the target key and return the value when found.</li>
</ol>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image07.png" alt="Search in Int32FrozenDictionary" />
<strong>
Figure 6 – Search in Int32FrozenDictionary
</strong></p>

<h3 id="benchmark-1">Benchmark</h3>

<p>Because of optimizations, reading from <code class="language-plaintext highlighter-rouge">Int32FrozenDictionary</code> is 34-42% faster (Figure 7).</p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image08.png" alt="Reading speed from Int32FrozenDictionary comparing to Dictionary" />
<strong>
Figure 7 – Reading speed from Int32FrozenDictionary comparing to Dictionary
</strong></p>

<h2 id="group-3-dictionary-with-bucket-sort-algorithm">Group 3. Dictionary with bucket sort algorithm</h2>

<p>When creating “frozen” dictionaries with string keys, <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> tries to create the <code class="language-plaintext highlighter-rouge">LengthBucketsFrozenDictionary</code> class. This class is optimized for situations where keys have different lengths. It achieves this by <a href="https://github.com/dotnet/runtime/blob/25f82f314b07cc96dd3212ca4ef950b4220516d1/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/LengthBuckets.cs#L17">distributing the keys into buckets</a>: for each unique key length, a bucket with a capacity of MaxPerLength = 5 elements is created. Essentially, this is an implementation of <a href="https://en.wikipedia.org/wiki/Bucket_sort">block sorting</a>. To make it clearer, let’s look at an example:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">dictionary</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Fruit</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;()</span>  
<span class="p">{</span>  
    <span class="p">[</span><span class="s">"apple"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"APPLE"</span><span class="p">,</span>  
    <span class="p">[</span><span class="s">"grape"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"GRAPE"</span><span class="p">,</span>  
    <span class="p">[</span><span class="s">"lemon"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"LEMON"</span><span class="p">,</span>  
    <span class="p">[</span><span class="s">"fig"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"FIG"</span><span class="p">,</span>  
    <span class="p">[</span><span class="s">"lime"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"LIME"</span><span class="p">,</span>  
    <span class="p">[</span><span class="s">"kiwi"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"KIWI"</span><span class="p">,</span>  
<span class="p">}</span>  
<span class="kt">var</span> <span class="n">frozenDictionary</span> <span class="p">=</span> <span class="n">dictionary</span><span class="p">.</span><span class="nf">ToFrozenDictionary</span><span class="p">();</span>
</code></pre></div></div>

<p>There are keys with length of 3, 4 and 5 in the dictionary. Therefore, they can be distributed between 3 buckets (Figure 8):</p>

<ol>
  <li>Bucket for keys of length 3: <code class="language-plaintext highlighter-rouge">fig</code>.</li>
  <li>Bucket for keys of length 4: <code class="language-plaintext highlighter-rouge">lime</code> and <code class="language-plaintext highlighter-rouge">kiwi</code>.</li>
  <li>Bucket for keys of length 5: <code class="language-plaintext highlighter-rouge">apple</code>, <code class="language-plaintext highlighter-rouge">grape</code>, and <code class="language-plaintext highlighter-rouge">lemon</code>.</li>
</ol>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image09.png" alt="Distribution of the strings based on their length" />
<strong>
Figure 8 – Distribution of the strings based on their length
</strong></p>

<p>Since we know the minimum (3) and maximum (5) lengths of the keys, there’s no need to create three separate buckets. We can store everything in a single array called <code class="language-plaintext highlighter-rouge">lengthBuckets</code>. In this case, the index is calculated like this: <code class="language-plaintext highlighter-rouge">(key.Length - minLength) * MaxPerLength</code>.</p>

<h3 id="search-algorithm-2">Search algorithm</h3>

<p>The search is done in 3 steps (Figure 9):</p>

<ol>
  <li>The bucket is determined in the <code class="language-plaintext highlighter-rouge">_lengthBuckets</code> array.</li>
  <li>A linear search in the bucket finds the index of the desired key in <code class="language-plaintext highlighter-rouge">_keys</code>.</li>
  <li>The value is returned.</li>
</ol>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image10.png" alt="Search in LengthBucketsFrozenDictionary" />
<strong>
Figure 9 – Search in LengthBucketsFrozenDictionary
</strong></p>

<p><code class="language-plaintext highlighter-rouge">LengthBucketsFrozenDictionary</code> has two limitations:</p>

<ol>
  <li>The number of keys with the same length must not exceed <code class="language-plaintext highlighter-rouge">MaxPerLength</code> (<a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">Pigeonhole Principle</a>). You can’t place 6 strings of the same length in a bucket with a capacity of 5 elements.</li>
  <li>The number of empty buckets must be less than 20%. Otherwise, the implementation becomes inefficient in terms of memory usage.</li>
</ol>

<p>If either of these conditions is not met, one of the <a href="https://github.com/dotnet/runtime/blob/e75fc2775a2c844ffd45e64b9a1b67b7e088959f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs">OrdinalStringFrozenDictionary</a> implementations will be chosen (more on that later).</p>

<h3 id="benchmark-2">Benchmark</h3>

<p>The benchmark results show that reading from a <code class="language-plaintext highlighter-rouge">LengthBucketsFrozenDictionary</code> can be up to 99% faster than a regular <code class="language-plaintext highlighter-rouge">Dictionary</code>. However, if the dictionary has 5 or more keys with the same length, the performance of small dictionaries (up to 100 items) can be worse (see Figure 10).</p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image11.png" alt="Reading speed LengthBucketsFrozenDictionary comparing to Dictionary" />
<strong>
Figure 10 – Reading speed LengthBucketsFrozenDictionary comparing to Dictionary
</strong></p>

<h2 id="group-4-dictionary-with-string-keys">Group 4. Dictionary with string keys</h2>

<p>As we already know, <code class="language-plaintext highlighter-rouge">LengthBucketsFrozenDictionary</code> has limitations. When it’s not possible to distribute keys into buckets, one of 11 implementations of the abstract class <a href="https://github.com/dotnet/runtime/blob/e75fc2775a2c844ffd45e64b9a1b67b7e088959f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs">OrdinalStringFrozenDictionary</a> is used. All of them use <code class="language-plaintext highlighter-rouge">FrozenHashTable</code>, but differ in the <a href="https://github.com/dotnet/runtime/blob/0378936909464c84cf207ffd1a21efa474fc34c0/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/Hashing.cs">algorithm for calculating the string’s hash code</a>.</p>

<p>The choice of the optimal <code class="language-plaintext highlighter-rouge">OrdinalStringFrozenDictionary</code> implementation depends on the key analysis by the <a href="https://github.com/dotnet/runtime/blob/d25d42e6dba95016cc1af95367a50c6b8b26efdd/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/KeyAnalyzer.cs">KeyAnalyzer class</a>. In turn, the result of the analysis depends on key length, the presence of non-ASCII characters, specified <a href="https://learn.microsoft.com/en-us/dotnet/api/system.stringcomparison">string comparison</a> rules and the presence of unique substrings in the keys.</p>

<p>Obviously, the longer the string, the slower the hash code calculation. Therefore, <code class="language-plaintext highlighter-rouge">KeyAnalyzer</code> tries to find the shortest substrings that allow the key to be uniquely identified. To better understand this, let’s revisit the example with fruits: <code class="language-plaintext highlighter-rouge">apple</code>, <code class="language-plaintext highlighter-rouge">grape</code>, <code class="language-plaintext highlighter-rouge">fig</code>, <code class="language-plaintext highlighter-rouge">lime</code>, <code class="language-plaintext highlighter-rouge">lemon</code>, and <code class="language-plaintext highlighter-rouge">kiwi</code>.</p>

<p>First, <code class="language-plaintext highlighter-rouge">KeyAnalyzer</code> analyzes substrings of length 1 with left-aligned keys (see Figure 11).</p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image12.png" alt="Single-char substrings with left and right algnment" />
<strong>
Figure 11 – Single-char substrings with left and right algnment
</strong></p>

<p>In this example, with left-aligned keys, there are repeating substrings. For instance, the 0th character of “lime” and “lemon” is the same, as well as the 1st character of “fig” and “lime” and the 2nd character of “lime” and “lemon.” This means that it is impossible to uniquely identify a key by a single character with such alignment. Therefore, the search for a substring continues with right-aligned keys. In this case, the substrings will be unique when using the 2nd or 1st character from the end. Knowing the alignment, starting index, and length of the substring, the string can be uniquely identified by calculating the hash code of its substring.</p>

<p>If there are no unique substrings of length 1, the search will continue for substrings of 2 characters, 3 characters, and so on, up to the maximum substring length. This value is calculated as the minimum between <code class="language-plaintext highlighter-rouge">minLength</code> (the shortest key length) and <code class="language-plaintext highlighter-rouge">MaxSubstringLengthLimit</code> = 8. This limitation is specifically set to avoid analyzing long substrings, as using them doesn’t improve performance.</p>

<p>If there is no unique substrings at all, the hash code will be calculated for the entire string.</p>

<p>In addition to the presence of unique substrings, the implementation is also <a href="https://github.com/dotnet/runtime/blob/0378936909464c84cf207ffd1a21efa474fc34c0/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/KeyAnalyzer.cs#L56">affected by the specified string comparison</a> parameters and the presence of non-ASCII characters. Based on these parameters, a more optimal comparator will be chosen.</p>

<h3 id="search-algorithm-3">Search algorithm</h3>

<p>Search in dictionaries based on <code class="language-plaintext highlighter-rouge">OrdinalStringFrozenDictionary</code> is <a href="https://github.com/dotnet/runtime/blob/98b165db27a3c15b9c0df208d1acca573b3dd15e/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs#L83">performed as follows</a>:</p>

<ol>
  <li>
    <p>First, it checks whether the key length is within the acceptable range. This allows for quickly discarding keys that clearly do not match due to their length.</p>
  </li>
  <li>
    <p>Next, the same steps that we’ve seen earlier in other dictionaries with <code class="language-plaintext highlighter-rouge">FrozenHashTable</code> are performed. The hash code of the substring is calculated, and a search is performed in the hash table. In case of a collision, a linear search is performed.</p>
  </li>
</ol>

<h3 id="benchmark-3">Benchmark</h3>

<p>According to the benchmark results, a <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> with up to 75,000 elements is faster than a regular <code class="language-plaintext highlighter-rouge">Dictionary</code>. However, as the dictionary size increases, the search speed becomes worse (see Figure 12).</p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image13.png" alt="Reading speed from OrdinalStringFrozenDictionary_LeftJustifiedSubstring comparing to Dictionary" />
<strong>
Рисунок 12 – Reading speed from OrdinalStringFrozenDictionary_LeftJustifiedSubstring comparing to Dictionary
</strong></p>

<p>The high speed of <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> is due to the fast hash code calculation of keys. The algorithm used in <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> is 75% to 90% faster than the one in a regular <code class="language-plaintext highlighter-rouge">Dictionary</code> (see Figure 13).</p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image14.png" alt="FrozenDictionary and Dictionary hash calculation speed" />
<strong>
Figure 13 – Hash calculation speed
</strong></p>

<p>The performance drop in dictionaries with 75,000 elements or more is caused by the increasing number of hash collisions as the dictionary size grows (see Figure 14).</p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image15.png" alt="FrozenDictionary and Dictinoary hash collisions count" />
<strong>
Figure 14 – Hash collisions count
</strong></p>

<p>As shown in the figures, the algorithm used in <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> significantly speeds up hash code calculation, improving performance by up to 70%. However, this approach negatively impacts search performance in relatively large dictionaries.</p>

<h2 id="group-5-small-dictionaries">Group 5. Small dictionaries</h2>

<p><code class="language-plaintext highlighter-rouge">SmallValueTypeComparableFrozenDictionary</code> and <code class="language-plaintext highlighter-rouge">SmallValueTypeDefaultComparerFrozenDictionary</code> are used when the original dictionary has no more than 10 elements, while <code class="language-plaintext highlighter-rouge">SmallFrozenDictionary</code> is used when it has no more than 4 elements. <code class="language-plaintext highlighter-rouge">SmallValueTypeComparableFrozenDictionary</code> is applied if the key type is a <a href="https://github.com/dotnet/runtime/blob/8e92aef5387fe1d4b9159b4a3657416ac7d0a05a/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/Constants.cs#L44">built-in primitive value type</a> (e.g., <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">enum</code>, etc.). If the key type is a custom structure, then <code class="language-plaintext highlighter-rouge">SmallValueTypeDefaultComparerFrozenDictionary</code> will be used. Developers on .NET explain this by noting that built-in types always implement the IComparable interface, allowing for a slight optimization in search by sorting the key and value arrays in advance.</p>

<h3 id="search-algorithm-4">Search algorithm</h3>

<p>Strictly speaking, the classes <code class="language-plaintext highlighter-rouge">SmallValueTypeComparableFrozenDictionary</code>, <code class="language-plaintext highlighter-rouge">SmallValueTypeDefaultComparerFrozenDictionary</code>, and <code class="language-plaintext highlighter-rouge">SmallFrozenDictionary</code> are not hash tables. The search for a value in these classes is performed using a simple linear search via a <code class="language-plaintext highlighter-rouge">for</code> loop (Figure 15).</p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image16.png" alt="Search in SmallValueTypeComparableFrozenDictionary" />
<strong>
Figure 15 – Search in SmallValueTypeComparableFrozenDictionary
</strong></p>

<p>In <code class="language-plaintext highlighter-rouge">SmallValueTypeComparableFrozenDictionary</code>, since the <code class="language-plaintext highlighter-rouge">_keys</code> and <code class="language-plaintext highlighter-rouge">_values</code> arrays are sorted, the search can continue as long as the searched key is greater than the current value of <code class="language-plaintext highlighter-rouge">_keys[i]</code>.</p>

<p>The implementations of <code class="language-plaintext highlighter-rouge">SmallValueTypeDefaultComparerFrozenDictionary</code> and <code class="language-plaintext highlighter-rouge">SmallFrozenDictionary</code> are similar to the previous one, except that sorting is not used. Therefore, a linear search through the <code class="language-plaintext highlighter-rouge">_keys</code> array will always be performed.</p>

<h3 id="benchmark-4">Benchmark</h3>

<p>Despite all the optimizations in these classes, the benchmark results do not look impressive (see Figure 16). Even the slight speedup that these classes can provide amounts to just a few tens of nanoseconds.</p>

<p><img src="/assets/2024/10/2024-10-09-frozen-dictionary/image17.png" alt="Reading speed from SmallValueTypeComparableFrozenDictionary, SmallValueTypeDefaultComparerFrozenDictionary and SmallFrozenDictionary comparing to Dictionary" />
<strong>
Figure 16 – Reading speed from SmallValueTypeComparableFrozenDictionary, SmallValueTypeDefaultComparerFrozenDictionary and SmallFrozenDictionary comparing to Dictionary
</strong></p>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, I tried to explain the main implementation features of <code class="language-plaintext highlighter-rouge">FrozenDictionary</code>. We made sure that in most cases <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> is faster than <code class="language-plaintext highlighter-rouge">Dictionary</code>.</p>

<p>Actually, there are lots of another algorithms and optimizations. For example, usage of <code class="language-plaintext highlighter-rouge">ArrayPool</code>, fast algorithm for modulus calculation, integer array with bit shift instead of boolean array etc. It would be impossible to do more detailed analysis in a single article. But from time to time I make such posts in my <a href="https://t.me/yet_another_dev">Telegram channel</a>. If you are interested, I will be glad to see you among the readers.</p>
</div><a class="u-url" href="/2024/10/09/frozen-dictionary.html" hidden></a>
</article>

<script
  src="https://utteranc.es/client.js"
  repo="alexeyfv/blog"
  issue-term="url"
  label="comment"
  theme="github-dark"
  crossorigin="anonymous"
  async
></script>

      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/"></data>
  
    <div class="wrapper">
  
      <div class="footer-col-wrapper">
        <div class="footer-col">
          <ul class="contact-list">
            <li class="p-name">© 2024 Alexey Fedorov</li>
              <li class="p-name">Powered by
                <a href="https://github.com/jekyll/jekyll">Jekyll</a> 
                &
                <a href="https://github.com/jekyll/minima">Minima</a>
              </li>
            </ul>
        </div>
        <div class="footer-col">
          <p>Articles about .NET, C# and much more</p>
        </div>
      </div>
  
      <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://www.linkedin.com/in/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li><li><a rel="me" href="https://t.me/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#telegram"></use></svg></a></li></ul></div>
  
    </div>
  
  </footer></body>

</html>
