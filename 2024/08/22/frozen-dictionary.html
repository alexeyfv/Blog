<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" sizes="16x16 32x32 48x48" href="/assets/favicon/favicon.ico">
    <link rel="apple-touch-icon" href="/assets/favicon/apple-touch-icon.png"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Заглядываем под капот FrozenDictionary: насколько он быстрее Dictionary и почему | alexeyfv</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Заглядываем под капот FrozenDictionary: насколько он быстрее Dictionary и почему" />
<meta name="author" content="© 2024 Alexey Fedorov" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="С релизом .NET 8 в арсенале C# разработчиков появилась новая коллекция – FrozenDictionary. Особенность этого словаря в том, что он неизменяемый, но при этом обеспечивает более быстрое чтение по сравнению с обычным Dictionary. Я неспроста разбил результаты на обложке по типам – используемые во FrozenDictinoary алгоритмы сильно зависят от типа ключа, размера словаря или даже, например, количества строковых ключей одинаковой длины. В этой статье подробно разберем, насколько FrozenDictionary быстрее и почему. English version is here." />
<meta property="og:description" content="С релизом .NET 8 в арсенале C# разработчиков появилась новая коллекция – FrozenDictionary. Особенность этого словаря в том, что он неизменяемый, но при этом обеспечивает более быстрое чтение по сравнению с обычным Dictionary. Я неспроста разбил результаты на обложке по типам – используемые во FrozenDictinoary алгоритмы сильно зависят от типа ключа, размера словаря или даже, например, количества строковых ключей одинаковой длины. В этой статье подробно разберем, насколько FrozenDictionary быстрее и почему. English version is here." />
<link rel="canonical" href="http://www.alexeyfv.xyz//2024/08/22/frozen-dictionary.html" />
<meta property="og:url" content="http://www.alexeyfv.xyz//2024/08/22/frozen-dictionary.html" />
<meta property="og:site_name" content="alexeyfv" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-08-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Заглядываем под капот FrozenDictionary: насколько он быстрее Dictionary и почему" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"© 2024 Alexey Fedorov"},"description":"С релизом .NET 8 в арсенале C# разработчиков появилась новая коллекция – FrozenDictionary. Особенность этого словаря в том, что он неизменяемый, но при этом обеспечивает более быстрое чтение по сравнению с обычным Dictionary. Я неспроста разбил результаты на обложке по типам – используемые во FrozenDictinoary алгоритмы сильно зависят от типа ключа, размера словаря или даже, например, количества строковых ключей одинаковой длины. В этой статье подробно разберем, насколько FrozenDictionary быстрее и почему. English version is here.","@type":"BlogPosting","headline":"Заглядываем под капот FrozenDictionary: насколько он быстрее Dictionary и почему","dateModified":"2024-08-22T00:00:00+00:00","datePublished":"2024-08-22T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.alexeyfv.xyz//2024/08/22/frozen-dictionary.html"},"url":"http://www.alexeyfv.xyz//2024/08/22/frozen-dictionary.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://www.alexeyfv.xyz//feed.xml" title="alexeyfv" />
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">alexeyfv</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/tags/">Tags</a><a class="page-link" href="/cv/">CV</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article
  class="post h-entry"
  itemscope
  itemtype="http://schema.org/BlogPosting"
>
  <link rel="stylesheet" href="/static/glide/css/glide.core.min.css" />
  <link rel="stylesheet" href="/static/glide/css/glide.theme.min.css" />
  <script type="text/javascript" src="/static/glide/glide.min.js"></script>
  <link href="/static/syntax-highlighting.css" rel="stylesheet" />
  <link href="/static/image.css" rel="stylesheet" />
  <script>
    function initGlideCarousel() {
      var sliders = document.querySelectorAll(".glide");
      const conf = {};
      sliders.forEach((item) => {
        new Glide(item, conf).mount();
      });
    }
    document.addEventListener("DOMContentLoaded", initGlideCarousel);
  </script>
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">
      Заглядываем под капот FrozenDictionary: насколько он быстрее Dictionary и почему
    </h1>
    <p class="post-meta"><time
        class="dt-published"
        datetime="2024-08-22T00:00:00+00:00"
        itemprop="datePublished"
      >
        Aug 22, 2024
      </time></p>
    
    <a class="post" href="/tag/csharp">#csharp</a>
    
    <a class="post" href="/tag/frozendictionary">#frozendictionary</a>
    
    <a class="post" href="/tag/dictionary">#dictionary</a>
    
    <a class="post" href="/tag/benchmark">#benchmark</a>
    
    <a class="post" href="/tag/hashtable">#hashtable</a>
    
    <a class="post" href="/tag/algorithms">#algorithms</a>
    
  </header>

  <div class="post-content e-content" itemprop="articleBody"><p>С <a href="https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8/runtime\#performance-focused-types">релизом .NET 8</a> в арсенале C# разработчиков появилась новая коллекция – <code class="language-plaintext highlighter-rouge">FrozenDictionary</code>. Особенность этого словаря в том, что он неизменяемый, но при этом обеспечивает более быстрое чтение по сравнению с обычным <code class="language-plaintext highlighter-rouge">Dictionary</code>. Я неспроста разбил результаты на обложке по типам – используемые во <code class="language-plaintext highlighter-rouge">FrozenDictinoary</code> алгоритмы сильно зависят от типа ключа, размера словаря или даже, например, количества строковых ключей одинаковой длины. В этой статье подробно разберем, насколько <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> быстрее и почему.</p>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image01.png" alt="Производительность FrozenDictionary по сравнению с Dictionary" /></p>

<p><em>English version is <a href="/2024/10/09/frozen-dictionary.html">here</a></em>.</p>

<!--more-->

<h2 id="оглавление">Оглавление</h2>

<ul>
  <li><a href="#оглавление">Оглавление</a></li>
  <li><a href="#dictionary-ты-один-приходи-мы-тоже-один-придём">Dictionary, ты один приходи. Мы тоже один придём</a></li>
  <li><a href="#дисклеймер">Дисклеймер</a></li>
  <li><a href="#группа-1-словари-по-умолчанию">Группа 1. Словари по умолчанию</a>
    <ul>
      <li><a href="#алгоритм-поиска">Алгоритм поиска</a></li>
      <li><a href="#бенчмарк">Бенчмарк</a></li>
    </ul>
  </li>
  <li><a href="#группа-2-словарь-для-ключей-типа-int32">Группа 2. Словарь для ключей типа Int32</a>
    <ul>
      <li><a href="#алгоритм-поиска-1">Алгоритм поиска</a></li>
      <li><a href="#бенчмарк-1">Бенчмарк</a></li>
    </ul>
  </li>
  <li><a href="#группа-3-словарь-с-алгоритмом-распределения-строк-по-длине">Группа 3. Словарь с алгоритмом распределения строк по длине</a>
    <ul>
      <li><a href="#алгоритм-поиска-2">Алгоритм поиска</a></li>
      <li><a href="#бенчмарк-2">Бенчмарк</a></li>
    </ul>
  </li>
  <li><a href="#группа-4-словари-с-ключом-типа-string">Группа 4. Словари с ключом типа string</a>
    <ul>
      <li><a href="#алгоритм-поиска-3">Алгоритм поиска</a></li>
      <li><a href="#бенчмарк-3">Бенчмарк</a></li>
    </ul>
  </li>
  <li><a href="#группа-5-небольшие-словари">Группа 5. Небольшие словари</a>
    <ul>
      <li><a href="#алгоритм-поиска-4">Алгоритм поиска</a></li>
      <li><a href="#бенчмарк-4">Бенчмарк</a></li>
    </ul>
  </li>
  <li><a href="#резюме">Резюме</a></li>
</ul>

<h2 id="dictionary-ты-один-приходи-мы-тоже-один-придём">Dictionary, ты один приходи. Мы тоже один придём</h2>

<p>Прежде чем начать <del>битву</del> сравнение с <code class="language-plaintext highlighter-rouge">Dictionary</code>, важно заметить, что <code class="language-plaintext highlighter-rouge">FrozenDictionary&lt;TKey, TValue&gt;</code> – это абстрактный класс с <a href="https://github.com/dotnet/runtime/tree/51e99e12a8a09c69e30fdcb004facf68f73173a6/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen">множеством реализаций</a>. Точнее, их 18. Вместо объяснений, когда какая реализация используется, проще показать на схеме, поэтому смотрим рисунок 1.</p>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image02.png" alt="Выбор реализации FrozenDictionary" />
<strong>Рисунок 1 – Выбор реализации FrozenDictionary</strong></p>

<p>Пугаться не стоит, реализации можно разделить на 5 групп по принципу работы:</p>

<ol>
  <li>В <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/DefaultFrozenDictionary.cs">DefaultFrozenDictionary</a> и <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/ValueTypeDefaultComparerFrozenDictionary.cs">ValueTypeDefaultComparerFrozenDictionary</a> используется структура <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs">FrozenHashTable</a>.</li>
  <li>В Int32FrozenDictionary тоже используется FrozenHashTable, но нет расчёта хэш-кода, поскольку значение ключа и есть хэш-код.</li>
  <li><a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/LengthBucketsFrozenDictionary.cs">LengthBucketsFrozenDictionary</a> использует алгоритм, похожий на <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">блочную сортировку</a>.</li>
  <li>Реализации <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs">OrdinalStringFrozenDictionary</a> тоже используют FrozenHashTable, но в них особенный алгоритм расчёт хэш-кода.</li>
  <li><a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallValueTypeComparableFrozenDictionary.cs\#L18">SmallValueTypeComparableFrozenDictionary</a>, <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallValueTypeDefaultComparerFrozenDictionary.cs\#L12">SmallValueTypeDefaultComparerFrozenDictionary</a> и <a href="https://github.com/dotnet/runtime/blob/8f74726e77b7ef4c00b90ad852b3917727e11e0c/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/SmallFrozenDictionary.cs\#L18">SmallFrozenDictionary</a> используют линейный поиск, так как размер словарей не превышает 10 элементов.</li>
</ol>

<p>Выбор подходящей реализации зависит от множества параметров и происходит в методе <a href="https://github.com/dotnet/runtime/blob/51e99e12a8a09c69e30fdcb004facf68f73173a6/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenDictionary.cs\#L113">CreateFromDictionary статического класса FrozenDictionary</a>. Теперь подробно рассмотрим каждую группу по отдельности, изучим их алгоритмы и сделаем замеры.</p>

<h2 id="дисклеймер">Дисклеймер</h2>

<p>Результаты бенчмарков в этой статье очень условны и верны только при определённых условиях. Допускаю, что бенчмарк может показать другие результаты на другом ПК, с другим ЦП, с другим компилятором или при другом сценарии использования рассматриваемого функционала языка. Всегда проверяйте ваш код на конкретно вашем железе и не полагайтесь лишь на статьи из интернета.</p>

<p>Исходный код бенчмарков и сырые данные результатов можно найти в <a href="https://github.com/alexeyfv/frozen-dictionary">этом репозитории</a>.</p>

<h2 id="группа-1-словари-по-умолчанию">Группа 1. Словари по умолчанию</h2>

<p>Как уже было сказано ранее, в <code class="language-plaintext highlighter-rouge">DefaultFrozenDictionary</code> и <code class="language-plaintext highlighter-rouge">ValueTypeDefaultComparerFrozenDictionary</code> используется структура <code class="language-plaintext highlighter-rouge">FrozenHashTable</code>. Эта структура, как можно догадаться из названия, представляет собой реализацию хэш-таблицы. Чтобы лучше понять, чем алгоритм в <code class="language-plaintext highlighter-rouge">FrozenHashTable</code> отличается от <code class="language-plaintext highlighter-rouge">Dictionary</code>, кратко вспомним, как устроен поиск в <code class="language-plaintext highlighter-rouge">Dictionary</code>. Если вы это помните, то можете пропустить объяснение.</p>

<p>Предположим, у нас есть следующий словарь:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">dictionary</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Fruit</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;()</span>  
<span class="p">{</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"apple"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"APPLE"</span><span class="p">,</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"grape"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"GRAPE"</span><span class="p">,</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"lemon"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"LEMON"</span><span class="p">,</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"fig"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"FIG"</span><span class="p">,</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"lime"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"LIME"</span><span class="p">,</span>  
    <span class="p">[</span><span class="k">new</span><span class="p">(</span><span class="s">"kiwi"</span><span class="p">)]</span> <span class="p">=</span> <span class="s">"KIWI"</span><span class="p">,</span>  
<span class="p">};</span>

<span class="k">public</span> <span class="n">record</span> <span class="nf">Fruit</span><span class="p">(</span><span class="kt">string</span> <span class="n">Value</span><span class="p">);</span>
</code></pre></div></div>

<p>Когда, например, мы ищем значение для ключа <code class="language-plaintext highlighter-rouge">Fruit("fig")</code>, в <code class="language-plaintext highlighter-rouge">Dictionary</code> происходит следующее (рисунок 2):</p>

<ol>
  <li>Вычисляется хэш код ключа <code class="language-plaintext highlighter-rouge">hashCode</code>.</li>
  <li>Рассчитывается индекса бакета <code class="language-plaintext highlighter-rouge">bucketIndex</code>.</li>
  <li>Если ключ в бакете равен искомому, то возвращается значение. Иначе переходим к следующему ключу с таким же хэш-кодом и повторяем п. 3.</li>
</ol>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image03.png" alt="Как осуществляется поиск элементов в Dictionary" />
<strong>Рисунок 2 – Пример поиска в Dictionary</strong></p>

<h3 id="алгоритм-поиска">Алгоритм поиска</h3>

<p>Иммутабельность <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> позволяет иначе реализовать работу с бакетами в <code class="language-plaintext highlighter-rouge">FrozenHashTable</code>. Поскольку количество пар ключ-значение не меняется, то можно:</p>

<ol>
  <li><a href="https://github.com/dotnet/runtime/blob/c788546f9ad43ea17981d5dc9343b00b6f76d98f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs\#L47">Подобрать</a> количество бакетов так, что количество коллизий будет <a href="https://github.com/dotnet/runtime/blob/3eba70227be23baee21c13a7ab9316d58d469b82/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenHashTable.cs\#L151">не более 5%</a> от количества уникальных хэшей.</li>
  <li>Разместить ключи и значения последовательно в массивах <code class="language-plaintext highlighter-rouge">_keys</code> и <code class="language-plaintext highlighter-rouge">_values</code>, вместо связного списка в <code class="language-plaintext highlighter-rouge">Dictionary</code>. Это сделает поиск более эффективным за счет более высокой локальности данных.</li>
</ol>

<p>При использовании <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> поиск значения для ключа <code class="language-plaintext highlighter-rouge">Fruit("fig")</code> выглядел бы следующим образом (рисунок 3):</p>

<ol>
  <li>Вычисляется хэш код ключа <code class="language-plaintext highlighter-rouge">hashCode</code>.</li>
  <li>Рассчитывается индекса бакета <code class="language-plaintext highlighter-rouge">bucketIndex</code>.</li>
  <li>В массиве <code class="language-plaintext highlighter-rouge">bucket</code> получаем значения <code class="language-plaintext highlighter-rouge">start</code> и <code class="language-plaintext highlighter-rouge">end</code>, задающие границы в массиве <code class="language-plaintext highlighter-rouge">HashCodes</code>.</li>
  <li>Итерируем массив <code class="language-plaintext highlighter-rouge">HashCodes</code> от <code class="language-plaintext highlighter-rouge">start</code> до <code class="language-plaintext highlighter-rouge">end</code>, в поисках искомого ключа и возвращаем значение при нахождении.</li>
</ol>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image04.png" alt="Как осуществляется поиск в DefaultFrozenDictionary" />
<strong>
Рисунок 3 – Пример поиска в DefaultFrozenDictionary
</strong></p>

<h3 id="бенчмарк">Бенчмарк</h3>

<p>Результаты бенчмарков для <code class="language-plaintext highlighter-rouge">DefaultFrozenDictionary</code> и <code class="language-plaintext highlighter-rouge">ValueTypeDefaultComparerFrozenDictionary</code> на рисунках 4 и 5.</p>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image05.png" alt="Скорость чтения из ValueTypeDefaultComparerFrozenDictionary по сравнению с Dictionary" />
<strong>
Рисунок 4 – Скорость чтения из ValueTypeDefaultComparerFrozenDictionary по сравнению с Dictionary
</strong></p>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image06.png" alt="Скорость чтения из DefaultFrozenDictionary по сравнению с Dictionary" />
<strong>
Рисунок 5 – Скорость чтения из DefaultFrozenDictionary по сравнению с Dictionary
</strong></p>

<p>Высокая скорость поиска в <code class="language-plaintext highlighter-rouge">Dictionary</code> по сравнению с <code class="language-plaintext highlighter-rouge">ValueTypeDefaultComparerFrozenDictionary</code> при размере словаря до 1000 элементов, вероятно, связана с агрессивным <a href="https://ru.wikipedia.org/wiki/%D0%92%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9">инлайном</a> методов <code class="language-plaintext highlighter-rouge">Dictionary</code>. Почему граница именно в 1000 элементов я понять не смог, т.к. в <a href="https://github.com/dotnet/runtime/blob/10107d3ca202bf1fda76a1bf575d782be4be27c3/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs">исходном коде</a> ничего об этом нет. Возможно это детали реализации JIT-компилятора. Если у вас есть идеи на этот счет, поделитесь в комментариях.</p>

<p>В остальных случаях, <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> быстрее на 31-32% для значимых типов и 17-18% для ссылочных типов.</p>

<h2 id="группа-2-словарь-для-ключей-типа-int32">Группа 2. Словарь для ключей типа Int32</h2>

<p><code class="language-plaintext highlighter-rouge">Int32FrozenDictionary</code> также использует <code class="language-plaintext highlighter-rouge">FrozenHashTable</code>. Особенность этой реализации в том, что если тип ключа – целое число, то его хэш равен его значению и коллизии в таком словаре не возможны в принципе. Нельзя, например, добавить 2 элемента с ключом 123 – будет выброшено исключение.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">dict</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;();</span>  
<span class="n">dict</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">123</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>  
<span class="n">dict</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">123</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span> <span class="c1">// System.ArgumentException: An item with the same key has already been added.</span>
</code></pre></div></div>

<h3 id="алгоритм-поиска-1">Алгоритм поиска</h3>

<p>Такая особенность <code class="language-plaintext highlighter-rouge">Int32FrozenDictionary</code> позволяет при чтении пропустить расчёт хэша и <a href="https://github.com/dotnet/runtime/blob/eb455ec34c6709e487c19e52c29ec712a6fa4d7f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/Int32/Int32FrozenDictionary.cs\#L35">использовать значение ключа напрямую</a>. В итоге, поиск значения выглядит так (рисунок 6):</p>

<ol>
  <li>Индекса бакета <code class="language-plaintext highlighter-rouge">bucketIndex</code> рассчитывается сразу по значению ключа.</li>
  <li>В массиве <code class="language-plaintext highlighter-rouge">bucket</code> получаем значения <code class="language-plaintext highlighter-rouge">start</code> и <code class="language-plaintext highlighter-rouge">end</code>, задающие границы в массиве <code class="language-plaintext highlighter-rouge">HashCodes</code>.</li>
  <li>Итерируем массив <code class="language-plaintext highlighter-rouge">HashCodes</code> от <code class="language-plaintext highlighter-rouge">start</code> до <code class="language-plaintext highlighter-rouge">end</code>, в поисках искомого ключа и возвращаем значение при нахождении.</li>
</ol>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image07.png" alt="Как осуществляется поиск в Int32FrozenDictionary" />
<strong>
Рисунок 6 – Пример поиска в Int32FrozenDictionary
</strong></p>

<h3 id="бенчмарк-1">Бенчмарк</h3>

<p>Благодаря оптимизациям, чтение из <code class="language-plaintext highlighter-rouge">Int32FrozenDictionary</code> быстрее на 34-42% (рисунок 7).</p>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image08.png" alt="Скорость чтения из Int32FrozenDictionary по сравнению с Dictionary" />
<strong>
Рисунок 7 – Скорость чтения из Int32FrozenDictionary по сравнению с Dictionary
</strong></p>

<h2 id="группа-3-словарь-с-алгоритмом-распределения-строк-по-длине">Группа 3. Словарь с алгоритмом распределения строк по длине</h2>

<p>При создании «замороженных» словарей со строковым ключом, <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> в первую очередь попытается создать класс <code class="language-plaintext highlighter-rouge">LengthBucketsFrozenDictionary</code>. Этот класс оптимизирован для ситуаций, когда ключи имеют разную длину. Достигается это <a href="https://github.com/dotnet/runtime/blob/25f82f314b07cc96dd3212ca4ef950b4220516d1/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/LengthBuckets.cs\#L17">распределением ключей по бакетам</a>: для каждой уникальной длины ключа создаётся бакет вместимостью <code class="language-plaintext highlighter-rouge">MaxPerLength = 5</code> элементов. По сути, это реализация <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">блочной сортировки</a>. Чтобы стало понятнее, рассмотрим пример:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">dictionary</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Fruit</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;()</span>  
<span class="p">{</span>  
    <span class="p">[</span><span class="s">"apple"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"APPLE"</span><span class="p">,</span>  
    <span class="p">[</span><span class="s">"grape"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"GRAPE"</span><span class="p">,</span>  
    <span class="p">[</span><span class="s">"lemon"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"LEMON"</span><span class="p">,</span>  
    <span class="p">[</span><span class="s">"fig"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"FIG"</span><span class="p">,</span>  
    <span class="p">[</span><span class="s">"lime"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"LIME"</span><span class="p">,</span>  
    <span class="p">[</span><span class="s">"kiwi"</span><span class="p">]</span> <span class="p">=</span> <span class="s">"KIWI"</span><span class="p">,</span>  
<span class="p">}</span>  
<span class="kt">var</span> <span class="n">frozenDictionary</span> <span class="p">=</span> <span class="n">dictionary</span><span class="p">.</span><span class="nf">ToFrozenDictionary</span><span class="p">();</span>
</code></pre></div></div>

<p>В словаре есть ключи длиной 3, 4 и 5 символов. Следовательно, их можно распределить в 3 бакета (рисунок 8):</p>

<ol>
  <li>Бакет для ключей длиной 3: <code class="language-plaintext highlighter-rouge">fig</code>.</li>
  <li>Бакет для ключей длиной 4: <code class="language-plaintext highlighter-rouge">lime</code> и <code class="language-plaintext highlighter-rouge">kiwi</code>.</li>
  <li>Бакет для ключей длиной 5: <code class="language-plaintext highlighter-rouge">apple</code>, <code class="language-plaintext highlighter-rouge">grape</code> и <code class="language-plaintext highlighter-rouge">lemon</code>.</li>
</ol>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image09.png" alt="Распределение строк по бакетам на основе их длины" />
<strong>
Рисунок 8 – Распределение строк по бакетам на основе их длины
</strong></p>

<p>Поскольку известна минимальная (3) и максимальная (5) длина ключей, нет смысла создавать 3 отдельных бакета. Можно всё хранить в одном массиве <code class="language-plaintext highlighter-rouge">_lengthBuckets</code>. В таком случае индекс рассчитывается так: <code class="language-plaintext highlighter-rouge">(key.Length - minLength) * MaxPerLength</code>.</p>

<h3 id="алгоритм-поиска-2">Алгоритм поиска</h3>

<p>Поиск осуществляется в 3 шага (рисунок 9):</p>

<ol>
  <li>Определяется бакет в массиве <code class="language-plaintext highlighter-rouge">_lengthBuckets</code>.</li>
  <li>Линейным поиском в бакете определяется индекс искомого ключа в <code class="language-plaintext highlighter-rouge">_keys</code>.</li>
  <li>Возвращается значение.</li>
</ol>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image10.png" alt="Как осуществляется поиск в LengthBucketsFrozenDictionary" />
<strong>
Рисунок 9 – Пример поиска в LengthBucketsFrozenDictionary
</strong></p>

<p>У <code class="language-plaintext highlighter-rouge">LengthBucketsFrozenDictionary</code> есть 2 ограничения:</p>

<ol>
  <li>Количество ключей с одинаковой длиной не должно превышать <code class="language-plaintext highlighter-rouge">MaxPerLength</code> (<a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%94%D0%B8%D1%80%D0%B8%D1%85%D0%BB%D0%B5_(%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D0%B8%D0%BA%D0%B0)">принцип Дирихле</a>). Нельзя разместить 6 строк с одинаковой длиной в бакет вместимостью 5 элементов.</li>
  <li>Количество пустых бакетов должно быть &lt; 20%. Иначе реализация становится неэффективна с точки зрения использования памяти.</li>
</ol>

<p>Если одно из этих условий не выполняется, то будет выбрана одна из реализаций <a href="https://github.com/dotnet/runtime/blob/e75fc2775a2c844ffd45e64b9a1b67b7e088959f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs">OrdinalStringFrozenDictionary</a> (о ней далее).</p>

<h3 id="бенчмарк-2">Бенчмарк</h3>

<p>Результаты бенчмарка показывают, что чтение из <code class="language-plaintext highlighter-rouge">LengthBucketsFrozenDictionary</code> может быть до 99% быстрее обычного <code class="language-plaintext highlighter-rouge">Dictionary</code>. Но если в словаре количество ключей с одинаковой длиной достигает 5, то производительность небольших словарей (до 100 элементов) может быть хуже (рисунок 10).</p>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image11.png" alt="Скорость чтения из LengthBucketsFrozenDictionary по сравнению с Dictionary" />
<strong>
Рисунок 10 – Скорость чтения из LengthBucketsFrozenDictionary по сравнению с Dictionary
</strong></p>

<h2 id="группа-4-словари-с-ключом-типа-string">Группа 4. Словари с ключом типа string</h2>

<p>Как мы уже знаем, у <code class="language-plaintext highlighter-rouge">LengthBucketsFrozenDictionary</code> есть ограничения. Поэтому, если невозможно распределить ключи по бакетам, используется одна из 11 реализаций абстрактного класса <a href="https://github.com/dotnet/runtime/blob/e75fc2775a2c844ffd45e64b9a1b67b7e088959f/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs">OrdinalStringFrozenDictionary</a>. Все они используют <code class="language-plaintext highlighter-rouge">FrozenHashTable</code>, но отличаются алгоритмом <a href="https://github.com/dotnet/runtime/blob/0378936909464c84cf207ffd1a21efa474fc34c0/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/Hashing.cs">расчёта хэш-кода строки</a>.</p>

<p>Выбор оптимальной реализации <code class="language-plaintext highlighter-rouge">OrdinalStringFrozenDictionary</code> зависит от результата анализа ключей <a href="https://github.com/dotnet/runtime/blob/d25d42e6dba95016cc1af95367a50c6b8b26efdd/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/KeyAnalyzer.cs">классом KeyAnalyzer</a>. На результат влияет длина ключей, наличие не-ASCII символов, заданные правила сравнения строк (<a href="https://learn.microsoft.com/en-us/dotnet/api/system.stringcomparison">StringComparison</a>) и наличие в ключах уникальных подстрок.</p>

<p>Очевидно, что чем длиннее строка, тем медленнее выполняется расчёт хэш-кода. Поэтому <code class="language-plaintext highlighter-rouge">KeyAnalyzer</code> пытается найти подстроки наименьшей длины, позволяющие однозначно идентифицировать ключ. Для лучшего понимания снова рассмотрим пример с фруктами: <code class="language-plaintext highlighter-rouge">apple</code>, <code class="language-plaintext highlighter-rouge">grape</code>, <code class="language-plaintext highlighter-rouge">fig</code>, <code class="language-plaintext highlighter-rouge">lime</code>, <code class="language-plaintext highlighter-rouge">lemon</code> и <code class="language-plaintext highlighter-rouge">kiwi</code>.</p>

<p>Сперва <code class="language-plaintext highlighter-rouge">KeyAnalyzer</code> анализирует подстроки длиной в 1 символ при левостороннем выравнивании ключей (рисунок 11).</p>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image12.png" alt="Подстроки длиной в 1 символ при левостороннем и правостороннем выравнивании ключей" />
<strong>
Рисунок 11 – Подстроки длиной в 1 символ при левостороннем и правостороннем выравнивании ключей
</strong></p>

<p>В нашем примере при левостороннем выравнивании есть повторяющиеся подстроки. Например, 0-й символ lime и lemon, 1-й символ fig и lime и 2-й символ в lime и lemon. То есть невозможно при таком выравнивании однозначно идентифицировать ключ по одному символу. Поэтому поиск подстроки продолжается при правостороннем выравнивании. В этом случае подстроки будут уникальны при использовании 2-го или 1-го символа с конца. Зная выравнивание, индекс начала и длину подстроки можно однозначно идентифицировать строку рассчитав хэш-код её подстроки.</p>

<p>Если уникальных подстрок длиной в 1 символ нет, то поиск продолжится для подстрок в 2 символа, 3 символа, вплоть до максимальной длины подстроки. Это значение рассчитывается как минимальное между <code class="language-plaintext highlighter-rouge">minLength</code> (минимальная длина ключа) и <code class="language-plaintext highlighter-rouge">MaxSubstringLengthLimit = 8</code>. Такое ограничение сделано специально, чтобы не анализировать слишком длинные подстроки, так как их использование не даёт прироста в производительности.</p>

<p>Если уникальных подстрок нет вообще, то расчёт хэш-кода будет производиться для всей строки.</p>

<p>Помимо наличия уникальных подстрок на реализацию также <a href="https://github.com/dotnet/runtime/blob/0378936909464c84cf207ffd1a21efa474fc34c0/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/KeyAnalyzer.cs\#L56">влияют заданные параметры сравнения строк (StringComparison)</a> и наличие не-ASCII символов. В зависимости от этих параметров будет выбран более оптимальный компаратор.</p>

<h3 id="алгоритм-поиска-3">Алгоритм поиска</h3>

<p>Поиск в словарях, основанных на <code class="language-plaintext highlighter-rouge">OrdinalStringFrozenDictionary</code>, происходит <a href="https://github.com/dotnet/runtime/blob/98b165db27a3c15b9c0df208d1acca573b3dd15e/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/String/OrdinalStringFrozenDictionary.cs\#L83">следующим образом</a>:</p>

<ol>
  <li>Проверяется, находится ли длина ключа в пределах допустимого диапазона. Это нужно для быстрого определения ключей, которые явно не подходят по длине.</li>
  <li>Далее, выполняются те же шаги, что мы ранее видели в других словарях с <code class="language-plaintext highlighter-rouge">FrozenHashTable</code>. Рассчитывается хэш-код подстроки и осуществляется поиск в хэш-таблице. В случае коллизии осуществляется линейный поиск.</li>
</ol>

<h3 id="бенчмарк-3">Бенчмарк</h3>

<p>По результатам бенчмарка, <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> размером до 75 тыс. элементов быстрее обычного <code class="language-plaintext highlighter-rouge">Dictionary</code>. Однако при дальнейшем увеличении размера словаря скорость поиска снижается (рисунок 12).</p>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image13.png" alt="Скорость чтения из OrdinalStringFrozenDictionary_LeftJustifiedSubstring по сравнению с Dictionary" />
<strong>
Рисунок 12 – Скорость чтения из OrdinalStringFrozenDictionary_LeftJustifiedSubstring по сравнению с Dictionary
</strong></p>

<p>Высокая скорость <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> обусловлена быстрым расчётом хэш-кода ключей. Алгоритм, используемый в <code class="language-plaintext highlighter-rouge">FrozenDictionary</code>, на 75% – 90% быстрее алгоритма обычного <code class="language-plaintext highlighter-rouge">Dictionary</code> (рисунок 13).</p>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image14.png" alt="Сравнение скорости расчёта хэша" />
<strong>
Рисунок 13 – Сравнение скорости расчёта хэша
</strong></p>

<p>Падение производительности в словарях размером 75 тыс. элементов и более вызвано возрастающим количеством коллизий хэша при увеличении размера словаря (рисунок 14).</p>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image15.png" alt="Количество коллизий при расчёте хэшей" />
<strong>
Рисунок 14 – Количество коллизий при расчёте хэшей
</strong></p>

<p>Как видно из графиков, алгоритм, используемый в <code class="language-plaintext highlighter-rouge">FrozenDictionary</code>, позволяет ускорить расчёт хэш-кода строки, улучшая производительность до 70%. Однако такой подход негативно сказывается на производительности поиска в относительно больших словарях.</p>

<h2 id="группа-5-небольшие-словари">Группа 5. Небольшие словари</h2>

<p><code class="language-plaintext highlighter-rouge">SmallValueTypeComparableFrozenDictionary</code>, <code class="language-plaintext highlighter-rouge">SmallValueTypeDefaultComparerFrozenDictionary</code> используются, когда в исходном словаре не более 10 элементов, а <code class="language-plaintext highlighter-rouge">SmallFrozenDictionary</code> – не более 4-х элементов. При этом, <code class="language-plaintext highlighter-rouge">SmallValueTypeComparableFrozenDictionary</code> применяется, если тип ключа – это <a href="https://github.com/dotnet/runtime/blob/8e92aef5387fe1d4b9159b4a3657416ac7d0a05a/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/Constants.cs\#L44">встроенный примитивный значимый тип</a> (<code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">enum</code> и т.д.). Если же тип ключа, к примеру, некоторая кастомная структура, то будет использован тип <code class="language-plaintext highlighter-rouge">SmallValueTypeDefaultComparerFrozenDictionary</code>. Такое разделение разработчики .NET объясняют тем, что у встроенных типов 100% реализован интерфейс IComparable и поэтому можно немного оптимизировать поиск, предварительно отсортировав массивы ключей и значений:</p>

<h3 id="алгоритм-поиска-4">Алгоритм поиска</h3>

<p>Строго говоря, классы <code class="language-plaintext highlighter-rouge">SmallValueTypeComparableFrozenDictionary</code>, <code class="language-plaintext highlighter-rouge">SmallValueTypeDefaultComparerFrozenDictionary</code> и <code class="language-plaintext highlighter-rouge">SmallFrozenDictionary</code> – это не хэш-таблицы. Поиск значения в них осуществляется простым линейным поиском через <code class="language-plaintext highlighter-rouge">for</code> (рисунок 15).</p>

<p><img src="/assets/2024/08/2024-08-22-frozen-dictionary/image16.png" alt="Как осуществляется поиск в SmallValueTypeComparableFrozenDictionary" />
<strong>
Рисунок 15 – Пример поиска в SmallValueTypeComparableFrozenDictionary
</strong></p>

<p>В <code class="language-plaintext highlighter-rouge">SmallValueTypeComparableFrozenDictionary</code>, поскольку массивы <code class="language-plaintext highlighter-rouge">_keys</code> и <code class="language-plaintext highlighter-rouge">_value</code> отсортированы, можно осуществлять поиск пока искомое значение ключа больше текущего значения <code class="language-plaintext highlighter-rouge">_keys[i]</code>.</p>

<p>Реализации <code class="language-plaintext highlighter-rouge">SmallValueTypeDefaultComparerFrozenDictionary</code> и <code class="language-plaintext highlighter-rouge">SmallFrozenDictionary</code> похожи на предыдущую, с тем лишь отличием, что в них не используется сортировка. Соответственно, линейный поиск по массиву ключей <code class="language-plaintext highlighter-rouge">_keys</code> будет осуществлён всегда.</p>

<h3 id="бенчмарк-4">Бенчмарк</h3>

<p>Несмотря на все оптимизации в этих классах, результаты бенчмарков не выглядят впечатляющими (рисунок 16). Даже то небольшое ускорение, которое могут дать эти классы, составляет всего лишь несколько десятков наносекунд.
<img src="/assets/2024/08/2024-08-22-frozen-dictionary/image17.png" alt="Скорость чтения из SmallValueTypeComparableFrozenDictionary, SmallValueTypeDefaultComparerFrozenDictionary и SmallFrozenDictionary по сравнению с Dictionary" />
<strong>
Рисунок 16 – Скорость чтения из SmallValueTypeComparableFrozenDictionary, SmallValueTypeDefaultComparerFrozenDictionary и SmallFrozenDictionary по сравнению с Dictionary
</strong></p>

<h2 id="резюме">Резюме</h2>

<p>В этой статье я постарался разобрать основные моменты, связанные с <code class="language-plaintext highlighter-rouge">FrozenDictionary</code>. Мы убедились, что <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> в большинстве случае действительно быстрее <code class="language-plaintext highlighter-rouge">Dictionary</code>.</p>

<p>На самом деле, в <code class="language-plaintext highlighter-rouge">FrozenDictionary</code> применяется ещё множество алгоритмов и оптимизаций. Например, использование пула массивов <code class="language-plaintext highlighter-rouge">ArrayPool</code>, оптимизированный алгоритм расчёта остатка от деления, использование массива целых чисел с битовыми сдвигами, вместо массива <code class="language-plaintext highlighter-rouge">bool</code> и т.д. Разбор всех деталей не получилось бы сделать в рамках одной статьи. Но я периодически делюсь подобными техническими тонкостями в коротких постах на <a href="https://t.me/yet_another_dev">своём Telegram-канале</a>. Если вам интересно, буду рад видеть вас среди читателей.</p>
</div><a class="u-url" href="/2024/08/22/frozen-dictionary.html" hidden></a>
</article>

<script
  src="https://utteranc.es/client.js"
  repo="alexeyfv/blog"
  issue-term="url"
  label="comment"
  theme="github-dark"
  crossorigin="anonymous"
  async
></script>

      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/"></data>
  
    <div class="wrapper">
  
      <div class="footer-col-wrapper">
        <div class="footer-col">
          <ul class="contact-list">
            <li class="p-name">© 2024 Alexey Fedorov</li>
              <li class="p-name">Powered by
                <a href="https://github.com/jekyll/jekyll">Jekyll</a> 
                &
                <a href="https://github.com/jekyll/minima">Minima</a>
              </li>
            </ul>
        </div>
        <div class="footer-col">
          <p>Articles about .NET, C# and much more</p>
        </div>
      </div>
  
      <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://www.linkedin.com/in/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li><li><a rel="me" href="https://t.me/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#telegram"></use></svg></a></li></ul></div>
  
    </div>
  
  </footer></body>

</html>
