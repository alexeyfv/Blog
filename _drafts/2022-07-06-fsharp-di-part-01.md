---
layout: post
title: "Внедрение зависимостей на F# (часть 1)"
date: 2022-07-06
tags: dotnet fsharp csharp functionalprogramming dependencyinjection
---

## Внедрение зависимостей - это передача аргумента

*Действительно ли внедрение зависимостей - это просто передача аргумента?*

Это первая статья из серии ["От внедрении зависимостей к отказу от зависимостей"](https://blog.ploeh.dk/2017/01/27/from-dependency-injection-to-dependency-rejection/).

В выступлении на Northeast Scala Symposium в 2012 году [Рунар Бьярнасон (Rúnar Bjarnason) вскользь подметил](https://youtu.be/ZasXwtTRkio), что внедрение зависимостей - это "на самом деле просто претенциозный способ сказать "принять аргумент". Учитывая, что я написал [книгу о внедрении зависимостей](https://www.amazon.com/gp/product/1935182501/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=1935182501&linkCode=as2&tag=ploeh-20) объёмом 500+ страниц, вы могли бы ожидать от меня возражений. Тем не менее, в этом есть доля правды, хотя и не всё так просто.

### Пример с бронированием столика в ресторане

Как и в других статьях этой серии примером будет сценарий с онлайн бронированием столика в ресторане. Представьте, что вас попросили разработать HTTP API, который принимает JSON содержащий данные о бронировании. Кроме того, предположим, что вы используете ASP.NET Web API в связке с C# для этого и вы стремитесь к соблюдению принципов [предметно-ориентированного проектирования](https://www.amazon.com/gp/product/0321125215/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0321125215&linkCode=as2&tag=ploeh-20).

Для обработки входящего POST запроса, вы могли бы написать метод примерно вот так:

``` csharp
public IHttpActionResult Post(ReservationRequestDto dto)
{
    var validationMsg = validator.Validate(dto);
    if (validationMsg != "")
        return this.BadRequest(validationMsg);
 
    var r = mapper.Map(dto);
    var id = maîtreD.TryAccept(r);
    if (id == null)
        return this.StatusCode(HttpStatusCode.Forbidden);
 
    return this.Ok();
}
```

> Maître D' (метрдотель) - лицо, координирующее работу обслуживания посетителей ресторана или постояльцев отеля.

Этот метод следует простому знакомому пути:

1. Проверка входных данных
2. Маппинг в модель предметной области
3. Делегирование указанной модели
4. Проверка результата
5. Возврат результата

Однако, вы могли заметить, что этот метод не делает всю работу сам. Он делегирует часть работы другим коллаборторам: `validate`, `mapper` и `maîtreD`. Откуда они берутся?

Эти объекты являются зависимостями. Можно ли сделать метод `Post` таким, чтобы он принимал эти зависимости?

К сожалению, нет. Метод `Post` является частью HTTP API. ASP NET Web API обрабатывает входящие HTTP-запросы по соглашению, и методы действий должны соответствовать этому соглашению. Вы не можете просто изменить метод так, чтобы он принимал дополнительные аргументы. Вам необходимо найти другое место для передачи этих зависимостей.

Второе подходящее место (после метода `Post`) для внедрения зависимостей - это конструктор:

``` csharp
public ReservationsController(
    IValidator validator,
    IMapper mapper,
    IMaîtreD maîtreD)
{            
    this.validator = validator;
    this.mapper = mapper;
    this.maîtreD = maîtreD;
}
```

Это применение паттерна *внедрение через конструктор*. Он сохраняет зависимости в полях класса, делая их доступными для других членов класса (например, метод `Post`).

### Черепахи - им нет конца

Вы можете возразить, что метод `Post` - это частный случай, т.к. он является частью API и поэтому должен следовать определённым правилам, а поскольку эти правила не применяются далее в коде, то вы бы могли реализовать остальные объекты просто передавая зависимости как аргументы.

Рассмотрим, в качестве примера, реализацию `IMaîtreD.TryAccept`:

``` csharp
public int? TryAccept(Reservation reservation)
{
 var reservedSeats = reservationsRepository
 .ReadReservations(reservation.Date)
 .Sum(r => r.Quantity);
 if (reservedSeats + reservation.Quantity <= capacity)
 {
 reservation.IsAccepted = true;
 return reservationsRepository.Create(reservation);
 }
 
 return null;
}
```

Этот метод содержит другой коллаборатор: `reservationsRepository`. Это очередная зависимость. Откуда она появилась? Можно ли сделать метод `TryAccept` таким, чтобы он принимал `reservationsRepository` как аргумент?

К сожалению, это тоже невозможно, потому что этот метод определён в интерфейсе `IMaîtreD`.

``` csharp
public interface IMaîtreD
{
    int? TryAccept(Reservation reservation);
}
```

Возможно, вы помните, что приведенный выше метод `Post` использует реализацию интерфейса `IMaîtreD`, а не конкретный класс. Добавление `IReservationsRepository` в качестве аргумента к `IMaîtreD.TryAccept` создало бы абстракцию с протечкой, потому что не всем реализациям интерфейса может потребоваться эта зависимость. Или, возможно, другая реализация имеет другую зависимость. Должны ли мы её тоже добавить в `IMaîtreD.TryAccept`?

Конечно, такой дизайн не является разумным. Используя внедрение через конструктор, вы можете отделить детали реализации от ваших абстракций:

``` csharp
public MaîtreD(int capacity, IReservationsRepository reservationsRepository)
{
    this.capacity = capacity;
    this.reservationsRepository = reservationsRepository;
}
```

Этот конструктор принимает не только реализацию `IReservationsRepository`, но также и `int`, представляющее вместимость рассматриваемого ресторана. Это показывает то, что зависимости могут быть также и примитивными типами.

### Итог

Внедрение зависимостей - это, в некотором смысле, только определенный способ для объектов принимать аргументы. Однако, часто объекты имеют роли, определенные реализуемыми ими интерфейсами. Таким объектам могут потребоваться коллабораторы, которые недоступны через API, определенные этими интерфейсами, поэтому вам придется предоставлять зависимости через члены, принадлежащие конкретному рассматриваемому классу. Внедрение зависимостей через конструктор класса - лучший способ сделать это.
