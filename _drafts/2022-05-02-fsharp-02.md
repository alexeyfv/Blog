---
layout: post
title: "Функциональное программирование на F# (часть 2)"
date: 2022-05-02
tags: dotnet fsharp csharp functionalprogramming
---

В прошлый раз [^1] мы написали модуль для расчёта ряда Фибоначчи практически не углубляясь в детали того, что из себя представляет F# и чем он отличается от кода на C#. В этой статье мы рассмотрим основные принципы F#, языковые конструкции, сравним их с аналогами на C# и исследуем скомпилированный код.

## Определение значений (Simple values)

Начнём с самого простого - объявления значений простых типов.

``` fsharp
let hello = "Hello, world!"
let mutable year = 2022
```

Как видно ниже, значение `hello` компилируется в статическое свойство с доступом только для чтения, т.е. в функцию, которая не принимает никаких аргументов и всегда возвращает одно и то же значение. Такое поведение является дефолтным для F# и таким образом достигается иммутабельность данных. Если же мы захотим изменять данные (чего делать не рекомендуется), то нужно добавить ключевое слово `mutable`. Тогда значение скомпилируется в свойство в котором будут и геттер и сеттер.

``` csharp
public static string hello => "Hello, world!";

public static int year { get; set; }
```

> Код на C#, эквивалентный коду на F#, из-за автоматической генерации кода декомпилятора занимает довольно много места. Здесь и далее я опустил некоторые несущественные детали, которые не влияют на смысл. Если интересна полная картина, то можно воспользоваться dotPeek [^2] или SharpLab [^3].

## Определение функций (Function values)

Теперь сделаем из `hello` функцию, которая принимает один параметр и добавляет его в строку, но реализуем это 4 разными способами. Как мы видим, функции определяются точно также, как и значения - через ключевое слово `let`. Вообще, это одна из главных особенностей функциональных языков программирования - функции являются объектами первого класса. [^4] Это значит, что функции сами являются значениями, т.е. могут быть входными аргументами или возвращаемыми параметрами.

``` fsharp
let hello1 x = $"Hello " + x + "!" 
let hello2 x = $"Hello {x}!"
let hello3 (x: string) = $"Hello {x}!" // explicit set type 'string' for an argument 'x'
let hello4 (x: int) = $"Hello {x}!" // explicit set type 'int' for an argument 'x'
let hello5 x : string = $"Hello {x}!" // explicit set output type
 ```

Эквивалентный код на C# представлен ниже. Реализация со складыванием строк простая, куда интереснее реализации с интерполяцией. Во-первых, функция `hello2` компилируется в обобщённый метод, т.к. мы не указали явно тип входного параметра. Во-вторых, то, во что компилируется интерполированная строка выглядит довольно объёмно.

``` csharp
public static string hello1(string x) => string.Concat("Hello ", x, "!");

// hello2 and hello5 have the same method body
public static string hello2<a>(a x)
{
    object[] array = new object[1];
    array[0] = x;
    return PrintfModule.PrintFormatToStringThen(
        new PrintfFormat<string, Unit, string, string, a>(
            "Hello %P()!", array, null));
}

public static string hello3(string x)
{
    object[] array = new object[1];
    array[0] = x;
    return PrintfModule.PrintFormatToStringThen(
        new PrintfFormat<string, Unit, string, string, string>(
            "Hello %P()!", array, null));
}

public static string hello4(int x)
{
    object[] array = new object[1];
    array[0] = x;
    return PrintfModule.PrintFormatToStringThen(
        new PrintfFormat<string, Unit, string, string, int>(
            "Hello %P()!", array, null));
}
```

Если заглянуть в CIL, то становится ещё интереснее. Вот, например, как выглядит промежуточный код для `hello3`:

``` csharp
.method public static string hello3 (string x) cil managed 
{
    .maxstack 8

    IL_0000: ldstr "Hello %P()!"
    IL_0005: ldc.i4.1
    IL_0006: newarr [System.Runtime]System.Object
    IL_000b: dup
    IL_000c: ldc.i4.0
    IL_000d: ldarg.0
    IL_000e: box [System.Runtime]System.String
    IL_0013: stelem [System.Runtime]System.Object
    IL_0018: ldnull
    IL_0019: newobj instance void class [FSharp.Core]Microsoft.FSharp.Core.PrintfFormat`5<string, class [FSharp.Core]Microsoft.FSharp.Core.Unit, string, string, string>::.ctor(string, object[], class [System.Runtime]System.Type[])
    IL_001e: tail.
    IL_0020: call !!0 [FSharp.Core]Microsoft.FSharp.Core.PrintfModule::PrintFormatToStringThen<string>(class [FSharp.Core]Microsoft.FSharp.Core.PrintfFormat`4<!!0, class [FSharp.Core]Microsoft.FSharp.Core.Unit, string, string>)
    IL_0025: ret
}
```

Теперь сравните с тем, во что компилируется аналогичный метод на C#:

``` csharp
public static string hello3 (int x) => $"Hello, {x}";
```

``` csharp
.method public hidebysig static string hello3 (string x) cil managed 
{
    .maxstack 8

    IL_0000: ldstr "Hello, "
    IL_0005: ldarg.0
    IL_0006: ldstr "!"
    IL_000b: call string [System.Runtime]System.String::Concat(string, string, string)
    IL_0010: ret
}
```

Наверняка это сказывается на производительности, но об этом как нибудь в другой раз.

## Типы и каррирование функций (Carrying)

Способов объявления одних и тех же функций может быть множество. Например, для F# вот эти две функции эквивалентны:

``` fsharp
let sum1 x y = x + y 
let sum2 x = fun y -> x + y // lambda-expression (or anonymous function)
```

Если попытаться явно переписать функции `sum1` и `sum2` на C#, то получилось бы примерно следующее:

``` csharp
// Invocation: int result = sum1(1, 2);
public int sum1(int x, int y) => x + y;

// Invocation: int result = sum2(1)(2);
public Func<int, int> sum2(int x) => (y) =>
{
    return x + y;
};
```

Очевидно, что точки зрения C# эти методы разные, несмотря на то, что результат вызова будет иметь значение `int`. Чтобы понять почему так, нужно разобраться, что значит тип в функциональных языках. В объектно-ориентированных языках программирования, когда мы говорим о типах, то мы подразумеваем классы или структуры. В функциональных языках же под типом понимается набор входных и выходных значений.

Можно возразить, что на F#, как и на C#, набор входных значений отличается - `sum1` принимает два аргумента, а `sum2` только один. На самом деле всё не совсем так. В F# одна функция, которая принимает множество параметров, преобразуются в множество функций, которые принимают по одному параметру. Таким образом, функция вида `(a, b) -> c`, превращается в `a -> b -> c` Такой метод преобразования называется каррированием. [^5]

Благодаря каррированию, функции `sum1` и `sum2` можно описать одним типом: 

``` fsharp
type operation = int -> int -> int
```

Эта странная запись читается слева направо и значит, что функция принимает на вход значение типа `int` и возвращает функцию, которая, в свою очередь, тоже принимает на вход значение `int` и возвращает значение `int`.

## Функции как входные и выходные параметры

Как упоминалось ранее, функции в F# - это объекты первого класса. Это значит, что можно записать вот так:

``` fsharp
let operationAsInput (op: operation) x y = op x y
let operationAsOutput : operation = fun x -> fun y -> x * y

let result = operationAsInput operationAsOutput 10 5 // result = 50
```

Рассмотрим подробнее, что тут происходит:

- Функция `operationAsInput` принимает на вход функцию `op` типа `operation` и значения `x` и `y`, а возвращает результат выполнения этой функции для `x` и `y`.
- Функция `operationAsOutput` возвращает другую функцию типа `operation`. В данном случае умножение двух чисел.
- Осуществляется вызов `operationAsInput`, в которую передаётся функция `operationAsOutput` и значения 10 и 5.

Возможность использования функций как параметров позволяет осуществлять таким образом композицию, внедрение зависимостей, реализовывать паттерны проектирования, но об этом поговорим в следующей статье.

Кстати, при компиляции код будет оптимизирован, поэтому на C# наши декомпилированные функции выглядят немного по-другому:

``` csharp
public static int operationAsInput(
    FSharpFunc<int, FSharpFunc<int, int>> op, int x, int y) => 
        FSharpFunc<int, int>.InvokeFast(op, x, y);

public static int operationAsOutput(int x, int y) => x * y;
```

## Операторы как функции

Как мы знаем, операторы в языках .NET - это методы. Например, оператор `+` для типа `int` после компиляции в CIL выглядит бы примерно так:

``` csharp
.method public hidebysig specialname static int32 op_Addition (
        int32 a,  int32 b) cil managed 
{
    // operator implementation
}
```

С точки зрения функционального программирования `op_Addition` - это функция, типа `int -> int -> int`. Поэтому, ниже представлены две пары эквивалентных записей:

``` fsharp
// int -> int -> int
let sumInfix x y = x + y
let sumPrefix x y = (+) x y

// int -> int
let incrementInfix x = x + 1
let incrementPrefix = (+) 1
```

Если посмотреть декомпилированный код на C#, то первые три функции выглядят вполне обычно.

``` csharp
public static int sumInfix(int x, int y) => return x + y;

public static int sumPrefix(int x, int y) => return x + y;

public static int incrementInfix(int x) => return x + 1;
```

Чего нельзя сказать об `incrementPrefix`:

- Во-первых, `incrementPrefix` компилируется в свойство типа `FSharpFunc<int, int>`
- Во-вторых, это свойство возвращает значение поля `incrementPrefix@8` из дополнительного класса `$_`
- В-третьих, полю `$_.incrementPrefix@8` присваивается значение поля `Functions.incrementPrefix@8.@_instance` в конструкторе типа `_$`

``` csharp
public static class Functions
{
    internal sealed class incrementPrefix@8 : FSharpFunc<int, int>
    {
        internal static readonly incrementPrefix@8 @_instance = new incrementPrefix@8();
        public override int Invoke(int y) => 1 + y;
    }

    public static FSharpFunc<int, int> incrementPrefix => $_.incrementPrefix@8;
}

internal static class $_
{
    internal static readonly FSharpFunc<int, int> incrementPrefix@8;

    static $_()
    {
        incrementPrefix@8 = Functions.incrementPrefix@8.@_instance;
    }
}
```

## Резюме

В этой статье рассмотрены ключевые принципы функциональных языков программирования:

- Функции - это объекты первого класса, т.е. могут быть входными аргументами или возвращаемыми параметрами.
- Возможность использования функций как параметров позволяет осуществлять композицию. При помощи композиции можно осуществлять внедрение зависимостей, реализовывать привычные паттерны проектирования из ООП.
- Под типом понимается не классы и структуры, а набор входных и выходных значений функций.

В следующей статье мы рассмотрим как в F# осуществляется внедрение зависимостей и реализуем часто встречающиеся паттерны.

## Ссылки и источники

[^1]: ["Функциональное программирование на F# (часть 1)"](https://www.alexeyfv.blog/2022/05/01/fsharp.html)
[^2]: [JetBrains dotPeek](https://www.jetbrains.com/ru-ru/decompiler/)
[^3]: [SharpLab](https://sharplab.io/)
[^4]: [First-class function](https://en.wikipedia.org/wiki/First-class_function)
[^5]: [Currying](https://en.wikipedia.org/wiki/Currying)
