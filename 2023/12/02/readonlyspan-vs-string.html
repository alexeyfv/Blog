<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" sizes="16x16 32x32 48x48" href="/assets/favicon/favicon.ico">
    <link rel="apple-touch-icon" href="/assets/favicon/apple-touch-icon.png"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>What is ReadOnlySpan in C# and how fast is it comparing to strings? | alexeyfv</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="What is ReadOnlySpan in C# and how fast is it comparing to strings?" />
<meta name="author" content="© 2024 Alexey Fedorov" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I already wrote an article about the fastest way of extracting substrings in C#. Now I want to investigate Span structures more. Recently, Microsoft released the .NET 8 platform which has several new extension methods for ReadOnlySpan&lt;T&gt;. So I want to compare the performance of MemoryExtensions methods with counterparts in string class." />
<meta property="og:description" content="I already wrote an article about the fastest way of extracting substrings in C#. Now I want to investigate Span structures more. Recently, Microsoft released the .NET 8 platform which has several new extension methods for ReadOnlySpan&lt;T&gt;. So I want to compare the performance of MemoryExtensions methods with counterparts in string class." />
<link rel="canonical" href="http://www.alexeyfv.xyz//2023/12/02/readonlyspan-vs-string.html" />
<meta property="og:url" content="http://www.alexeyfv.xyz//2023/12/02/readonlyspan-vs-string.html" />
<meta property="og:site_name" content="alexeyfv" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-12-02T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="What is ReadOnlySpan in C# and how fast is it comparing to strings?" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"© 2024 Alexey Fedorov"},"description":"I already wrote an article about the fastest way of extracting substrings in C#. Now I want to investigate Span structures more. Recently, Microsoft released the .NET 8 platform which has several new extension methods for ReadOnlySpan&lt;T&gt;. So I want to compare the performance of MemoryExtensions methods with counterparts in string class.","@type":"BlogPosting","headline":"What is ReadOnlySpan in C# and how fast is it comparing to strings?","dateModified":"2023-12-02T00:00:00+00:00","datePublished":"2023-12-02T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.alexeyfv.xyz//2023/12/02/readonlyspan-vs-string.html"},"url":"http://www.alexeyfv.xyz//2023/12/02/readonlyspan-vs-string.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://www.alexeyfv.xyz//feed.xml" title="alexeyfv" />
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">alexeyfv</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/tags/">Tags</a><a class="page-link" href="/cv/">CV</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article
  class="post h-entry"
  itemscope
  itemtype="http://schema.org/BlogPosting"
>
  <link rel="stylesheet" href="/static/glide/css/glide.core.min.css" />
  <link rel="stylesheet" href="/static/glide/css/glide.theme.min.css" />
  <script type="text/javascript" src="/static/glide/glide.min.js"></script>
  <link href="/static/syntax-highlighting.css" rel="stylesheet" />
  <link href="/static/image.css" rel="stylesheet" />
  <script>
    function initGlideCarousel() {
      var sliders = document.querySelectorAll(".glide");
      const conf = {};
      sliders.forEach((item) => {
        new Glide(item, conf).mount();
      });
    }
    document.addEventListener("DOMContentLoaded", initGlideCarousel);
  </script>
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">
      What is ReadOnlySpan&lt;T&gt; in C# and how fast is it comparing to strings?
    </h1>
    <p class="post-meta"><time
        class="dt-published"
        datetime="2023-12-02T00:00:00+00:00"
        itemprop="datePublished"
      >
        Dec 2, 2023
      </time></p>
    
    <a class="post" href="/tag/csharp">#csharp</a>
    
    <a class="post" href="/tag/benchmark">#benchmark</a>
    
  </header>

  <div class="post-content e-content" itemprop="articleBody"><p>I already wrote an article about the fastest way of extracting substrings in C#. Now I want to investigate Span structures more. Recently, Microsoft released the .NET 8 platform which has several new <a href="https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions?view=net-8.0">extension methods</a> for <code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code>. So I want to compare the performance of <code class="language-plaintext highlighter-rouge">MemoryExtensions</code> methods with counterparts in string class.</p>

<h2 id="benchmark">Benchmark</h2>

<p>All the benchmarks use a JSON-file with a string array of size 135 892 elements. Each array element represents the different permissions for different folders. Strings has the following template:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;permission&gt; for Folder: \\server-name\path\to\folder\
</code></pre></div></div>

<p>For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DENY Permission for Folder: \\server-name\path\to\folder\
</code></pre></div></div>

<p>My employer won’t be happy if I share the file, so you should trust me that this file contains such data. :)</p>

<p>In this benchmark, we’ll consider the following 8 methods:</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">string</code></th>
      <th><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.contains?view=net-8.0">Contains</a></td>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.contains?view=net-8.0">Contains</a></td>
    </tr>
    <tr>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.startswith?view=net-8.0">StartsWith</a></td>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.startswith?view=net-8.0">StartsWith</a></td>
    </tr>
    <tr>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.indexof?view=net-8.0">IndexOf</a></td>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.indexof?view=net-8.0">IndexOf</a></td>
    </tr>
    <tr>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.replace?view=net-8.0">Replace</a></td>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.replace?view=net-8.0">Replace</a></td>
    </tr>
    <tr>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.split?view=net-8.0">Split</a></td>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.split?view=net-8.0">Split</a></td>
    </tr>
    <tr>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.tolowerinvariant?view=net-8.0">ToLowerInvariant</a></td>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.tolower?view=net-8.0">ToLowerInvariant</a></td>
    </tr>
    <tr>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.trim?view=net-8.0">Trim</a></td>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.trim?view=net-8.0">Trim</a></td>
    </tr>
    <tr>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.substring?view=net-8.0">Substring</a></td>
      <td><a href="https://learn.microsoft.com/en-us/dotnet/api/system.span-1.slice?view=net-8.0">Slice</a></td>
    </tr>
  </tbody>
</table>

<p>In the context of Span-based methods, we also take into account the "Span + Allocation" scenario, which involves string allocation using the ToString method where applicable. This scenario arises when Span-based methods are initially used, but the ultimate outcome includes the allocation of a string through the ToString method.</p>

<p>As usual, for benchmarking, I used the <a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet</a> library. The whole code of the benchmark class can be found <a href="https://gitlab.com/alexeyfv/readonlyspan-vs-string">here</a>.</p>

<h2 id="results">Results</h2>

<h3 id="contains">Contains</h3>

<p>The benchmark assesses whether each string in the provided collection contains the backslash character.</p>

<table>
  <thead>
    <tr>
      <th><strong>Benchmark</strong></th>
      <th><strong>Mean execution time, μs</strong></th>
      <th><strong>Execution time ratio</strong></th>
      <th><strong>Gen 0 collections per 1000 operations</strong></th>
      <th><strong>Allocated memory, bytes</strong></th>
      <th><strong>Allocated ratio</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>615.7</td>
      <td>–</td>
      <td>0</td>
      <td>1</td>
      <td>–</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code></td>
      <td>624.1</td>
      <td>-2%</td>
      <td>0</td>
      <td>1</td>
      <td>–</td>
    </tr>
  </tbody>
</table>

<h3 id="startswith">StartsWith</h3>

<p>The benchmark evaluates whether each string in the given collection starts with the specified substring.</p>

<table>
  <thead>
    <tr>
      <th><strong>Benchmark</strong></th>
      <th><strong>Mean execution time, μs</strong></th>
      <th><strong>Execution time ratio</strong></th>
      <th><strong>Gen 0 collections per 1000 operations</strong></th>
      <th><strong>Allocated memory, bytes</strong></th>
      <th><strong>Allocated ratio</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>56 681.1</td>
      <td>–</td>
      <td>0</td>
      <td>82</td>
      <td>–</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code></td>
      <td>329.6</td>
      <td>-99.4%</td>
      <td>0</td>
      <td>0</td>
      <td>-100%</td>
    </tr>
  </tbody>
</table>

<h3 id="indexof">IndexOf</h3>

<p>The benchmark retrieves the index of the substring "Folder" within each string in the given collection.</p>

<table>
  <thead>
    <tr>
      <th><strong>Benchmark</strong></th>
      <th><strong>Mean execution time, μs</strong></th>
      <th><strong>Execution time ratio</strong></th>
      <th><strong>Gen 0 collections per 1000 operations</strong></th>
      <th><strong>Allocated memory, bytes</strong></th>
      <th><strong>Allocated ratio</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>224 182.4</td>
      <td>–</td>
      <td>0</td>
      <td>245</td>
      <td>–</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code></td>
      <td>1 131.6</td>
      <td>-99.5%</td>
      <td>0</td>
      <td>1</td>
      <td>-99.6%</td>
    </tr>
  </tbody>
</table>

<h3 id="split">Split</h3>

<p>This benchmark, designed as a synthetic test, utilizes the Split method to determine the maximum number of substrings between separators in each string within the provided collection.</p>

<table>
  <thead>
    <tr>
      <th><strong>Benchmark</strong></th>
      <th><strong>Mean execution time, μs</strong></th>
      <th><strong>Execution time ratio</strong></th>
      <th><strong>Gen 0 collections per 1000 operations</strong></th>
      <th><strong>Allocated memory, bytes</strong></th>
      <th><strong>Allocated ratio</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>16 241.3</td>
      <td>–</td>
      <td>4468.75</td>
      <td>56 127 351</td>
      <td>–</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code></td>
      <td>9 977.2</td>
      <td>-39%</td>
      <td>0</td>
      <td>1060</td>
      <td>-100%</td>
    </tr>
  </tbody>
</table>

<h3 id="replace">Replace</h3>

<p>These benchmarks focus on replacing backslashes with forward slashes in each string within the provided collection, using different methods for string manipulation.</p>

<table>
  <thead>
    <tr>
      <th><strong>Benchmark</strong></th>
      <th><strong>Mean execution time, μs</strong></th>
      <th><strong>Execution time ratio</strong></th>
      <th><strong>Gen 0 collections per 1000 operations</strong></th>
      <th><strong>Allocated memory, bytes</strong></th>
      <th><strong>Allocated ratio</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>3 156.8</td>
      <td>–</td>
      <td>2019.53</td>
      <td>25 353 195</td>
      <td>–</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code></td>
      <td>2 663.0</td>
      <td>-16%</td>
      <td>0</td>
      <td>3</td>
      <td>-100%</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code> with allocation</td>
      <td>16 701.5</td>
      <td>+430%</td>
      <td>2015.62</td>
      <td>25 353 204</td>
      <td>-0%</td>
    </tr>
  </tbody>
</table>

<h3 id="tolowerinvariant">ToLowerInvariant</h3>

<p>These benchmarks focus on converting each string within the provided collection to lowercase, utilizing different methods for case transformation.</p>

<table>
  <thead>
    <tr>
      <th><strong>Benchmark</strong></th>
      <th><strong>Mean execution time, μs</strong></th>
      <th><strong>Execution time ratio</strong></th>
      <th><strong>Gen 0 collections per 1000 operations</strong></th>
      <th><strong>Allocated memory, bytes</strong></th>
      <th><strong>Allocated ratio</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>3 771.3</td>
      <td>–</td>
      <td>2019.53</td>
      <td>25 353 195</td>
      <td>–</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code></td>
      <td>3 884.3</td>
      <td>+3%</td>
      <td>0</td>
      <td>3</td>
      <td>-100%</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code> with allocation</td>
      <td>17 938.6</td>
      <td>+374%</td>
      <td>2015.62</td>
      <td>25 353 204</td>
      <td>-0%</td>
    </tr>
  </tbody>
</table>

<h3 id="trim">Trim</h3>

<p>These benchmarks focus on trimming trailing backslashes from the specified substring in each string within the provided collection, utilizing various approaches to achieve the desired result.</p>

<table>
  <thead>
    <tr>
      <th><strong>Benchmark</strong></th>
      <th><strong>Mean execution time, μs</strong></th>
      <th><strong>Execution time ratio</strong></th>
      <th><strong>Gen 0 collections per 1000 operations</strong></th>
      <th><strong>Allocated memory, bytes</strong></th>
      <th><strong>Allocated ratio</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>687.4</td>
      <td>–</td>
      <td>–</td>
      <td>553</td>
      <td>–</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code></td>
      <td>469.1</td>
      <td>-32%</td>
      <td>–</td>
      <td>–</td>
      <td>-99.8%</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code> with allocation</td>
      <td>2 968.1</td>
      <td>+332%</td>
      <td>2019.53</td>
      <td>25 353 195</td>
      <td>+4 584 565%</td>
    </tr>
  </tbody>
</table>

<h3 id="substring">Substring</h3>

<p>These benchmarks focus on extracting a substring between specific markers in each string within the provided collection, using different methods to achieve the desired substring extraction.</p>

<table>
  <thead>
    <tr>
      <th><strong>Benchmark</strong></th>
      <th><strong>Mean execution time, μs</strong></th>
      <th><strong>Execution time ratio</strong></th>
      <th><strong>Gen 0 collections per 1000 operations</strong></th>
      <th><strong>Allocated memory, bytes</strong></th>
      <th><strong>Allocated ratio</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>1 523.8</td>
      <td>–</td>
      <td>779.3</td>
      <td>9784225</td>
      <td>–</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code></td>
      <td>347.9</td>
      <td>-77%</td>
      <td>–</td>
      <td>–</td>
      <td>-100%</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code> with allocation</td>
      <td>1 694.5</td>
      <td>+11%</td>
      <td>779.3</td>
      <td>9784225</td>
      <td>+0%</td>
    </tr>
  </tbody>
</table>

<h2 id="conclusion">Conclusion</h2>

<h3 id="readonlyspant-without-allocation"><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code> without allocation</h3>

<p><img src="/assets/2023/12/2023-12-02-readonlyspan-vs-string/image1.png" alt="content" />
<strong>ReadOnlySpan execution ratio</strong></p>

<p>As we can see from the figure above, almost all extension methods for <code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code> are faster than analogues from string class. The only exception is the <code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;.ToLower</code> method. I assume that It is because <a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/MemoryExtensions.Globalization.cs#L223">this method copies the characters from the source span into the destination</a>.</p>

<h3 id="readonlyspant-with-allocation"><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code> with allocation</h3>

<p><img src="/assets/2023/12/2023-12-02-readonlyspan-vs-string/image2.png" alt="content" />
<strong>ReadOnlySpan with allocation execution ratio</strong></p>

<p>The string.Replace, string.ToLower, string.TrimEnd, string.Substring methods outperform the combination of <code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;</code> methods and <a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/ReadOnlySpan.cs#L332"><code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;.ToString</code></a>. This difference is likely due to efficient implementations of these methods. For example, invoking the <a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/String.Manipulation.cs#L2198"><code class="language-plaintext highlighter-rouge">string.TrimEnd</code></a> leads to a call of the <a href="https://github.com/microsoft/referencesource/blob/master/mscorlib/system/buffer.cs#L299"><code class="language-plaintext highlighter-rouge">Buffer.Memmove</code></a> method. It appears that the string allocation process using <code class="language-plaintext highlighter-rouge">Buffer.Memmove</code> is more efficient than the implementation of <code class="language-plaintext highlighter-rouge">ReadOnlySpan&lt;T&gt;.ToString</code>.</p>

<h3 id="memory-consumption">Memory consumption</h3>

<p>Span-based methods exhibit superior memory efficiency, with zero memory allocations and no observed Gen 0 collections. String methods, particularly in operations like <code class="language-plaintext highlighter-rouge">Split</code>, <code class="language-plaintext highlighter-rouge">Replace</code>, and <code class="language-plaintext highlighter-rouge">ToLower</code>, tend to incur more significant memory allocations and, in some cases, Gen 0 collections. Therefore, for memory-conscious applications, utilizing Span-based methods may offer performance advantages in terms of reduced memory footprint and improved garbage collection behavior.</p>

<p>Notice almost the same or even worse results for the “Span + Allocation” column. Despite the utilization of Span-based methods in the intermediate steps, the inclusion of string allocation in the final outcome appears to negate some of the memory efficiency gained by using Span. This indicates that, in this specific context, the allocation of strings during or after Span-based operations may mitigate the potential memory benefits associated with using Span.</p>

<p>Generation 0 collections per 1000 operations</p>

<table>
  <thead>
    <tr>
      <th>Categories</th>
      <th>String</th>
      <th>Span</th>
      <th>Span + Allocation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Contains</code></td>
      <td>0</td>
      <td>0</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">StartsWith</code></td>
      <td>0</td>
      <td>0</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IndexOf</code></td>
      <td>0</td>
      <td>0</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Split</code></td>
      <td>4468.75</td>
      <td>0</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Replace</code></td>
      <td>2019.5313</td>
      <td>0</td>
      <td>2015.625</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ToLower</code></td>
      <td>2019.5313</td>
      <td>0</td>
      <td>2015.625</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Trim</code></td>
      <td>1333.3333</td>
      <td>0</td>
      <td>2019.5313</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Substring</code></td>
      <td>779.3</td>
      <td>0</td>
      <td>779.3</td>
    </tr>
  </tbody>
</table>

<p>Memory allocated, Mb</p>

<table>
  <thead>
    <tr>
      <th>Categories</th>
      <th>String</th>
      <th>Span</th>
      <th>Span + Allocation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Contains</code></td>
      <td>0.00</td>
      <td>0.00</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">StartsWith</code></td>
      <td>0.00</td>
      <td>0.00</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">IndexOf</code></td>
      <td>0.00</td>
      <td>0.00</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Split</code></td>
      <td>53.53</td>
      <td>0.00</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Replace</code></td>
      <td>24.18</td>
      <td>0.00</td>
      <td>24.18</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ToLower</code></td>
      <td>24.18</td>
      <td>0.00</td>
      <td>24.18</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Trim</code></td>
      <td>0.00</td>
      <td>0.00</td>
      <td>24.17</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Substring</code></td>
      <td>9.33</td>
      <td>0.00</td>
      <td>9.33</td>
    </tr>
  </tbody>
</table>

<h2 id="further-reading">Further reading</h2>

<ol>
  <li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions?view=net-8.0">MemoryExtensions Class</a>.</li>
  <li><a href="https://adamsitnik.com/files/Spanification_Prague.pdf">Spanification</a>.</li>
  <li><a href="https://prodotnetmemory.com/">Pro .NET Memory Management</a>.</li>
</ol>
</div><a class="u-url" href="/2023/12/02/readonlyspan-vs-string.html" hidden></a>
</article>

<script
  src="https://utteranc.es/client.js"
  repo="alexeyfv/blog"
  issue-term="url"
  label="comment"
  theme="github-dark"
  crossorigin="anonymous"
  async
></script>

      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/"></data>
  
    <div class="wrapper">
  
      <div class="footer-col-wrapper">
        <div class="footer-col">
          <ul class="contact-list">
            <li class="p-name">© 2024 Alexey Fedorov</li>
              <li class="p-name">Powered by
                <a href="https://github.com/jekyll/jekyll">Jekyll</a> 
                &
                <a href="https://github.com/jekyll/minima">Minima</a>
              </li>
            </ul>
        </div>
        <div class="footer-col">
          <p>Articles about .NET, C# and much more</p>
        </div>
      </div>
  
      <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://www.linkedin.com/in/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li><li><a rel="me" href="https://t.me/alexeyfv" target="_blank" title="alexeyfv"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#telegram"></use></svg></a></li></ul></div>
  
    </div>
  
  </footer></body>

</html>
